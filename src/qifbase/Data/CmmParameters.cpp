// Copyright(c) Capvidia, 2020
// https://www.capvidia.com
//
// Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software
// and accompanying documentation covered by this license(the "Software") to use, reproduce, display, distribute, execute,
// and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the Software
// is furnished to do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement,
// including the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and all derivative works of the Software,
// unless such copies or derivative works are solely in the form of machine-executable object code generated by a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT.
// IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#include "stdafx.h"
#include "CmmParameters.h"
#include <math.h>

namespace qifbase
{
/// <summary> Compares two double values with 1e-10 precision. </summary>
/// <param name="a"> The first number to compare </param>
/// <param name="b"> The second number to compare </param>
/// <returns> True if the numbers are equal, otherwise false </returns>
static bool DoublesEqual(double a, double b)
{
    constexpr double RESABS = 1e-10;
    if(abs(a - b) > RESABS)
        return true;
    return false;
}

/// <summary> Default constructor. </summary>
CmmParameters::CmmParameters()
{
    // Set up the default values for the parameters

    // CMM general
    _name = L"<unnammed CMM>";
    _zero.push_back(0);
    _zero.push_back(0);
    _zero.push_back(0);
    _extents.push_back(1000);
    _extents.push_back(1000);
    _extents.push_back(1000);
    _cmmType = CmmType::MovingBridge;
    _cmmAxisOrientationX = CmmAxisOrientation::PlusA;
    _cmmAxisOrientationY = CmmAxisOrientation::PlusB;
    _cmmAxisOrientationZ = CmmAxisOrientation::PlusC;
    _activePerformanceTest = CmmPerformanceTest::None;
    _b89Results = std::unique_ptr<CmmErrorB89>(new CmmErrorB89());
    _iso10360Results = std::unique_ptr<CmmErrorIso10360>(new CmmErrorIso10360());

    // Environment data
    _cmmScalesType = CmmScalesType::Standard;
    _cmmTemperature = 20;
    _cmmTemperatureUncertainty = 0;
    _cmmExpansionCoefficient = 0;
    _cmmExpansionCoefficientUncertainty = 0;
    _cmmLaserAirTemperature = 20;
    _cmmLaserAirTemperatureUncertainty = 0;
    _cmmLaserAirPressure = 101.325;
    _cmmLaserAirPressureUncertainty = 0;
    _cmmLaserAirHumidity = 0;
    _cmmLaserAirHumidityUncertainty = 0;
    _cmmSoftwareCompensationType = CmmSoftwareCompensationType::SingleTemperatureAssumed;

    // rotary table
    _hasRotaryTable = false;
    _rotaryTableRadius = 300;
    _rotaryTableXOrigin = 0;
    _rotaryTableYOrigin = 0;
    _rotaryTableZOrigin = 0;
    _rotaryTableAxisDirection.push_back(0);
    _rotaryTableAxisDirection.push_back(0);
    _rotaryTableAxisDirection.push_back(1);
    _rotaryTableZeroIndexDirection.push_back(1);
    _rotaryTableZeroIndexDirection.push_back(0);
    _rotaryTableZeroIndexDirection.push_back(0);
    _rotaryTableAxialError = 0;
    _rotaryTableRadialError = 0;
    _rotaryTableTangentialError = 0;
}

/// <summary> Copy constructor. </summary>
/// <param name="copy"> Object to copy </param>
CmmParameters::CmmParameters(const CmmParameters& copy)
{
    _name = copy._name;
    _zero = copy._zero;
    _extents = copy._extents;
    _cmmType = copy._cmmType;
    _cmmAxisOrientationX = copy._cmmAxisOrientationX;
    _cmmAxisOrientationY = copy._cmmAxisOrientationY;
    _cmmAxisOrientationZ = copy._cmmAxisOrientationZ;
    _activePerformanceTest = copy._activePerformanceTest;
    _b89Results = std::unique_ptr<CmmErrorB89>(new CmmErrorB89(*(copy._b89Results.get())));
    _iso10360Results = std::unique_ptr<CmmErrorIso10360>(new CmmErrorIso10360(*(copy._iso10360Results.get())));
    for(std::vector<SensorParameters*>::const_iterator it = copy._sensors.begin(); it != copy._sensors.end(); it++)
        _sensors.push_back(new SensorParameters(**it));

    _cmmScalesType = copy._cmmScalesType;
    _cmmTemperature = copy._cmmTemperature;
    _cmmTemperatureUncertainty = copy._cmmTemperatureUncertainty;
    _cmmExpansionCoefficient = copy._cmmExpansionCoefficient;
    _cmmExpansionCoefficientUncertainty = copy._cmmExpansionCoefficientUncertainty;
    _cmmLaserAirTemperature = copy._cmmLaserAirTemperature;
    _cmmLaserAirTemperatureUncertainty = copy._cmmLaserAirTemperatureUncertainty;
    _cmmLaserAirPressure = copy._cmmLaserAirPressure;
    _cmmLaserAirPressureUncertainty = copy._cmmLaserAirPressureUncertainty;
    _cmmLaserAirHumidity = copy._cmmLaserAirHumidity;
    _cmmLaserAirHumidityUncertainty = copy._cmmLaserAirHumidityUncertainty;
    _cmmSoftwareCompensationType = copy._cmmSoftwareCompensationType;

    _hasRotaryTable = copy._hasRotaryTable;
    _rotaryTableRadius = copy._rotaryTableRadius;
    _rotaryTableXOrigin = copy._rotaryTableXOrigin;
    _rotaryTableYOrigin = copy._rotaryTableYOrigin;
    _rotaryTableZOrigin = copy._rotaryTableZOrigin;
    _rotaryTableAxialError = copy._rotaryTableAxialError;
    _rotaryTableRadialError = copy._rotaryTableRadialError;
    _rotaryTableTangentialError = copy._rotaryTableTangentialError;
    _rotaryTableAxisDirection = copy._rotaryTableAxisDirection;
    _rotaryTableZeroIndexDirection = copy._rotaryTableZeroIndexDirection;
}

/// <summary> Adds a sensor to the list of Sensors </summary>
/// <param name="sensor"> sensor </param>
void CmmParameters::AddSensor(SensorParameters* sensor)
{
    _sensors.push_back(sensor);
}

/// <summary>
/// Adds a sensor to the list of Sensors at the given index.
/// Returns null if the index was out of bounds, and the sensor not inserted.
/// </summary>
/// <param name="index"> Index </param>
/// <param name="sensor"> Sensor to add </param>
/// <returns> False if the index was out of bounds, and the sensor not inserted. Otherwise returns true. </returns>
bool CmmParameters::AddSensorAtIndex(size_t index, SensorParameters* sensor)
{
    if(index > _sensors.size())
        return false;

    std::vector<SensorParameters*>::iterator it = _sensors.begin() + index;
    _sensors.insert(it, sensor);
    return true;
}

/// <summary> Removes a sensor from the list of Sensors.  </summary>
/// <param name="sensor"> Sensor to remove </param>
/// <returns> Returns true if the sensor was found and removed from the list. </returns>
bool CmmParameters::RemoveSensor(SensorParameters* sensor)
{
    for(auto it = _sensors.begin(); it != _sensors.end(); it++)
    {
        if(*it == sensor)
        {
            _sensors.erase(it);
            return true;
        }
    }
    return false;
}

/// <summary> Equality operator. </summary>
/// <param name="other"> Object to compare </param>
/// <returns> True if objects are equal, otherwise false </returns>
bool CmmParameters::operator == (const CmmParameters& other) const
{
    // CMM-specific data
    if(_name != other._name)
        return false;
    if(_zero != other._zero)
        return false;
    if(_extents != other._extents)
        return false;
    if(_cmmType != other._cmmType)
        return false;
    if(_cmmAxisOrientationX != other._cmmAxisOrientationX)
        return false;
    if(_cmmAxisOrientationY != other._cmmAxisOrientationY)
        return false;
    if(_cmmAxisOrientationZ != other._cmmAxisOrientationZ)
        return false;
    if(_activePerformanceTest != other._activePerformanceTest)
        return false;
    if((_b89Results == nullptr && other._b89Results != nullptr) ||
       (other._b89Results == nullptr && _b89Results != nullptr) ||
       !(*_b89Results == *(other._b89Results)))
        return false;
    if((_iso10360Results == nullptr && other._iso10360Results != nullptr) ||
       (other._iso10360Results == nullptr && _iso10360Results != nullptr) ||
       !(*_iso10360Results == *(other._iso10360Results)))
        return false;

    // Compare sensors
    const auto nSensor = _sensors.size();
    if(nSensor != other._sensors.size())
        return false;
    for(int i = 0; i < nSensor; ++i)
    {
        if(*_sensors[i] != *other._sensors[i])
            return false;
    }

    // Environment data
    if(_cmmScalesType != other._cmmScalesType)
        return false;
    if(DoublesEqual(_cmmTemperature, other._cmmTemperature))
        return false;
    if(DoublesEqual(_cmmTemperatureUncertainty, other._cmmTemperatureUncertainty))
        return false;
    if(_cmmExpansionCoefficient != other._cmmExpansionCoefficient)
        return false;
    if(_cmmExpansionCoefficientUncertainty != other._cmmExpansionCoefficientUncertainty)
        return false;
    if(_cmmLaserAirTemperature != other._cmmLaserAirTemperature)
        return false;
    if(_cmmLaserAirTemperatureUncertainty != other._cmmLaserAirTemperatureUncertainty)
        return false;
    if(_cmmLaserAirPressure != other._cmmLaserAirPressure)
        return false;
    if(_cmmLaserAirPressureUncertainty != other._cmmLaserAirPressureUncertainty)
        return false;
    if(_cmmLaserAirHumidity != other._cmmLaserAirHumidity)
        return false;
    if(_cmmLaserAirHumidityUncertainty != other._cmmLaserAirHumidityUncertainty)
        return false;
    if(_cmmSoftwareCompensationType != other._cmmSoftwareCompensationType)
        return false;

    // Rotary table data
    if(_hasRotaryTable != other._hasRotaryTable)
        return false;
    if(_rotaryTableRadius != other._rotaryTableRadius)
        return false;
    if(_rotaryTableXOrigin != other._rotaryTableXOrigin)
        return false;
    if(_rotaryTableYOrigin != other._rotaryTableYOrigin)
        return false;
    if(_rotaryTableZOrigin != other._rotaryTableZOrigin)
        return false;
    if(_rotaryTableAxisDirection != other._rotaryTableAxisDirection)
        return false;
    if(_rotaryTableZeroIndexDirection != other._rotaryTableZeroIndexDirection)
        return false;
    if(_rotaryTableAxialError != other._rotaryTableAxialError)
        return false;
    if(_rotaryTableRadialError != other._rotaryTableRadialError)
        return false;
    if(_rotaryTableTangentialError != other._rotaryTableTangentialError)
        return false;

    return true;
}

/// <summary> Gets the description for this CMM in the given units. </summary>
/// <param name="units"> Units </param>
/// <returns> Description </returns>
std::wstring CmmParameters::GetDescription(Units units)
{
    std::wstring description = L"";
    std::wstring unitString = std::wstring(L" " + UnitsMethods::UnitString(units));

    // CMM Name
    description += L"--------------------------------------------------------------------------------\n";
    description += L"Description for CMM: " + _name + L"\n";

    // CMM Types
    description += L"\nCMM Type: \n\t";
    description += CmmTypeMethods::Name(_cmmType) + L"\n";

    // Extents
    description += L"\nCMM Extents: \n\t";
    description += std::to_wstring(UnitsMethods::Convert(Units::mm, units, _zero[0])) + unitString + L",  ";
    description += std::to_wstring(UnitsMethods::Convert(Units::mm, units, _zero[1])) + unitString + L",  ";
    description += std::to_wstring(UnitsMethods::Convert(Units::mm, units, _zero[2])) + unitString + L"\n\t";
    description += std::to_wstring(UnitsMethods::Convert(Units::mm, units, _extents[0])) + unitString + L",  ";
    description += std::to_wstring(UnitsMethods::Convert(Units::mm, units, _extents[1])) + unitString + L",  ";
    description += std::to_wstring(UnitsMethods::Convert(Units::mm, units, _extents[2])) + unitString + L"\n";

    // Environment Data
    description += L"\nCMM Environmental Data\n";
    if(_cmmScalesType == CmmScalesType::Standard)
    {
        description += L"\tCMM uses Standard Scales.\n";
        description += L"\t                      Machine Temperature: " + std::to_wstring(_cmmTemperature) + L"°C\n";
        description += L"\t          Machine Temperature Uncertainty: " + std::to_wstring(_cmmTemperatureUncertainty) + L"°C\n";
        description += L"\t            Machine Expansion Coefficient: " + std::to_wstring(_cmmExpansionCoefficient) + L"ppm/°C\n";
        description += L"\tMachine Expansion Coefficient Uncertainty: " + std::to_wstring(_cmmExpansionCoefficientUncertainty) + L"ppm/°C\n";
    }
    else // Laser Scales
    {
        description += L"\tCMM uses Laser Scales.\n";
        description += L"\t                 Air Temperature: " + std::to_wstring(_cmmLaserAirTemperature) + L"°C\n";
        description += L"\t     Air Temperature Uncertainty: " + std::to_wstring(_cmmLaserAirTemperatureUncertainty) + L"°C\n";
        description += L"\t            Atmospheric Pressure: " + std::to_wstring(_cmmLaserAirPressure) + L"kPa\n";
        description += L"\tAtmospheric Pressure Uncertainty: " + std::to_wstring(_cmmLaserAirPressureUncertainty) + L"kPa\n";
        description += L"\t               Relative Humidity: " + std::to_wstring(_cmmLaserAirHumidity) + L"%\n";
        description += L"\t   Relative Humidity Uncertainty: " + std::to_wstring(_cmmLaserAirHumidityUncertainty) + L"%\n";
    }
    description += L"\tCMM Temperature Software Compensation:  ";
    if(_cmmSoftwareCompensationType == CmmSoftwareCompensationType::NoCompensation)
        description += L"No temperature compensation\n";
    else if(_cmmSoftwareCompensationType == CmmSoftwareCompensationType::CmmOnly)
        description += L"CMM only\n";
    else if(_cmmSoftwareCompensationType == CmmSoftwareCompensationType::SingleTemperatureAssumed)
        description += L"CMM and workpiece, but workpiece is assumed to be the same temperature as the CMM\n";
    else if(_cmmSoftwareCompensationType == CmmSoftwareCompensationType::FullCompensation)
        description += L"Full temperature compensation\n";

    // Active performance test
    description += L"\nActive Performance Test: " + CmmPerformanceTestMethods::Name(_activePerformanceTest) + L"\n";

    // B89 Numbers
    if(_b89Results != nullptr)
    {
        description += L"\nASME B89.4.1 Performance Test Values:\n";
        description += L"\t         Linear Accuracy in X: " + std::to_wstring(UnitsMethods::Convert(Units::mm, units, _b89Results->XLinearAccuracy())) + unitString + L"\n";
        description += L"\t         Linear Accuracy in Y: " + std::to_wstring(UnitsMethods::Convert(Units::mm, units, _b89Results->YLinearAccuracy())) + unitString + L"\n";
        description += L"\t         Linear Accuracy in Z: " + std::to_wstring(UnitsMethods::Convert(Units::mm, units, _b89Results->ZLinearAccuracy())) + unitString + L"\n";
        description += L"\t       Volumetric Performance: " + std::to_wstring(UnitsMethods::Convert(Units::mm, units, _b89Results->VolumetricPerformance())) + unitString + L"\n";
        description += L"\tOffset Volumetric Performance: " + std::to_wstring(_b89Results->OffsetVolumetricPerformance()) + L" ppm\n";
        description += L"\t                Repeatability: " + std::to_wstring(UnitsMethods::Convert(Units::mm, units, _b89Results->Repeatability())) + unitString + L"\n";
    }

    // ISO 10360 numbers
    if(_iso10360Results != nullptr)
    {
        description += L"\nISO 10360 Performance Test Values:\n";
        if(_iso10360Results->ErrorOfIndicationType() == CmmErrorIso10360::ErrorType::OneValue)
            description += L"\tE = ±" + std::to_wstring(UnitsMethods::Convert(Units::mm, units, _iso10360Results->ErrorOfIndicationValue3())) + unitString + L"\n";
        else if(_iso10360Results->ErrorOfIndicationType() == CmmErrorIso10360::ErrorType::TwoValues)
        {
            description += L"\tE = ±" + std::to_wstring(UnitsMethods::Convert(Units::mm, units, _iso10360Results->ErrorOfIndicationValue1())) + unitString;
            description += L" + " + std::to_wstring(UnitsMethods::Convert(Units::mm, units, _iso10360Results->ErrorOfIndicationValue2())) + unitString;
            description += L" x [L(" + unitString + L") / " + std::to_wstring(UnitsMethods::Convert(Units::m, units, 1)) + unitString + L"]\n";
        }
        else if(_iso10360Results->ErrorOfIndicationType() == CmmErrorIso10360::ErrorType::ThreeValues)
        {
            description += L"\tE = ± minimum of:\n\t\t" + std::to_wstring(UnitsMethods::Convert(Units::mm, units, _iso10360Results->ErrorOfIndicationValue1())) + unitString;
            description += L" + " + std::to_wstring(UnitsMethods::Convert(Units::mm, units, _iso10360Results->ErrorOfIndicationValue2())) + unitString;
            description += L" x [L(" + unitString + L") / " + std::to_wstring(UnitsMethods::Convert(Units::m, units, 1)) + unitString + L"]\n";
            description += L"\t\tor " + std::to_wstring(UnitsMethods::Convert(Units::mm, units, _iso10360Results->ErrorOfIndicationValue3())) + unitString + L"\n";
        }
        description += L"\tISO 10360 performance test carried out with ";
        if(_iso10360Results->Artifact() == CmmErrorIso10360::ArtifactType::GageBlocks)
            description += L"Gage Blocks\n";
        else
            description += L"Bidirectional Step Gage\n";
    }

    // Sensors
    if(!_sensors.empty())
    {
        description += L"\nThis CMM has " + std::to_wstring(_sensors.size()) + L" sensor(s) that can be used:\n";
        for(std::vector<SensorParameters*>::iterator it = _sensors.begin(); it != _sensors.end(); it++)
            description += L"\t" + (*it)->Name() + L"\n";
    }

    // Rotary Table, if it has one
    if(_hasRotaryTable)
    {
        description += L"\nThis CMM has a Rotary Table at location:\n";
        description += L"\t" + std::to_wstring(UnitsMethods::Convert(Units::mm, units, _rotaryTableXOrigin));
        description += L", " + std::to_wstring(UnitsMethods::Convert(Units::mm, units, _rotaryTableYOrigin));
        description += L", " + std::to_wstring(UnitsMethods::Convert(Units::mm, units, _rotaryTableZOrigin)) + L"\n";
        description += L"\t     Axial Error: " + std::to_wstring(UnitsMethods::Convert(Units::mm, units, _rotaryTableAxialError)) + unitString;
        description += L"\t    Radial Error: " + std::to_wstring(UnitsMethods::Convert(Units::mm, units, _rotaryTableRadialError)) + unitString;
        description += L"\tTangential Error: " + std::to_wstring(UnitsMethods::Convert(Units::mm, units, _rotaryTableTangentialError)) + unitString;
        description += L"\n";
    }

    description += L"--------------------------------------------------------------------------------\n";
    return description;
}
}

// Copyright(c) Capvidia, 2020
// https://www.capvidia.com
//
// Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software
// and accompanying documentation covered by this license(the "Software") to use, reproduce, display, distribute, execute,
// and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the Software
// is furnished to do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement,
// including the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and all derivative works of the Software,
// unless such copies or derivative works are solely in the form of machine-executable object code generated by a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT.
// IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#pragma once
#include "../decl_qifbase.h"
#include "CmmType.h"
#include "CmmAxisOrientation.h"
#include "CmmPerformanceTest.h"
#include "CmmErrorB89.h"
#include "CmmErrorIso10360.h"
#include "SensorParameters.h"
#include "CmmScalesType.h"
#include "CmmSoftwareCompensationType.h"
#include "Units.h"

#include <vector>
#include <string>
#include <memory>

template class QIFBASE_EXPORT std::unique_ptr<qifbase::CmmErrorB89>;
template class QIFBASE_EXPORT std::unique_ptr<qifbase::CmmErrorIso10360>;
template class QIFBASE_EXPORT std::vector<qifbase::SensorParameters*>;

namespace qifbase
{
/// <summary> Represents a CMM. </summary>
class QIFBASE_EXPORT CmmParameters
{
public:
    CmmParameters();
    CmmParameters(const CmmParameters& copy);

    // Name
    std::wstring Name() const { return _name; }
    void Name(std::wstring value) { _name = value; }

    // Zero
    const std::vector<double>& Zero() const { return _zero; }
    void Zero(const std::vector<double>& value) { _zero = value; }

    // Extents. Represents three-dimensional working volume (normally size() == 3)
    const std::vector<double>& Extents() const { return _extents; }
    void Extents(const std::vector<double>& value) { _extents = value; }

    // Type
    CmmType Type() const { return _cmmType; }
    void Type(CmmType value) { _cmmType = value; }

    // AxisOrientationX
    CmmAxisOrientation AxisOrientationX() const { return _cmmAxisOrientationX; }
    void AxisOrientationX(CmmAxisOrientation value) { _cmmAxisOrientationX = value; }

    // AxisOrientationY
    CmmAxisOrientation AxisOrientationY() const { return _cmmAxisOrientationY; }
    void AxisOrientationY(CmmAxisOrientation value) { _cmmAxisOrientationY = value; }

    // AxisOrientationZ
    CmmAxisOrientation AxisOrientationZ() const { return _cmmAxisOrientationZ; }
    void AxisOrientationZ(CmmAxisOrientation value) { _cmmAxisOrientationZ = value; }

    // ActivePerformanceTest
    CmmPerformanceTest ActivePerformanceTest() const { return _activePerformanceTest; }
    void ActivePerformanceTest(CmmPerformanceTest value) { _activePerformanceTest = value; }

    // B89Results
    CmmErrorB89* B89Results() const { return _b89Results.get(); }
    void B89Results(const CmmErrorB89* value) { _b89Results = std::unique_ptr<CmmErrorB89>(new CmmErrorB89(*value)); }

    // Iso10360Results
    CmmErrorIso10360* Iso10360Results() const { return _iso10360Results.get(); }
    void Iso10360Results(const CmmErrorIso10360* value) { _iso10360Results = std::unique_ptr<CmmErrorIso10360>(new CmmErrorIso10360(*value)); }

    // Sensors
    std::vector<SensorParameters*>& Sensors() { return _sensors; }
    void Sensors(const std::vector<SensorParameters*>& value) { _sensors = value; }

    // CmmScales
    CmmScalesType CmmScales() const { return _cmmScalesType; }
    void CmmScales(CmmScalesType value) { _cmmScalesType = value; }

    // CmmTemperature
    double CmmTemperature() const { return _cmmTemperature; }
    void CmmTemperature(double value) { _cmmTemperature = value; }

    // CmmTemperatureUncertainty
    double CmmTemperatureUncertainty() const { return _cmmTemperatureUncertainty; }
    void CmmTemperatureUncertainty(double value) { _cmmTemperatureUncertainty = value; }

    // CmmExpansionCoefficient
    double CmmExpansionCoefficient() const { return _cmmExpansionCoefficient; }
    void CmmExpansionCoefficient(double value) { _cmmExpansionCoefficient = value; }

    // CmmExpansionCoefficientUncertainty
    double CmmExpansionCoefficientUncertainty() const { return _cmmExpansionCoefficientUncertainty; }
    void CmmExpansionCoefficientUncertainty(double value) { _cmmExpansionCoefficientUncertainty = value; }

    // CmmLaserAirTemperature
    double CmmLaserAirTemperature() const { return _cmmLaserAirTemperature; }
    void CmmLaserAirTemperature(double value) { _cmmLaserAirTemperature = value; }

    // CmmLaserAirTemperatureUncertainty
    double CmmLaserAirTemperatureUncertainty() const { return _cmmLaserAirTemperatureUncertainty; }
    void CmmLaserAirTemperatureUncertainty(double value) { _cmmLaserAirTemperatureUncertainty = value; }

    // CmmLaserAirPressure
    double CmmLaserAirPressure() const { return _cmmLaserAirPressure; }
    void CmmLaserAirPressure(double value) { _cmmLaserAirPressure = value; }

    // CmmLaserAirPressureUncertainty
    double CmmLaserAirPressureUncertainty() const { return _cmmLaserAirPressureUncertainty; }
    void CmmLaserAirPressureUncertainty(double value) { _cmmLaserAirPressureUncertainty = value; }

    // CmmLaserAirHumidity
    double CmmLaserAirHumidity() const { return _cmmLaserAirHumidity; }
    void CmmLaserAirHumidity(double value) { _cmmLaserAirHumidity = value; }

    // CmmLaserAirHumidityUncertainty
    double CmmLaserAirHumidityUncertainty() const { return _cmmLaserAirHumidityUncertainty; }
    void CmmLaserAirHumidityUncertainty(double value) { _cmmLaserAirHumidityUncertainty = value; }

    // CmmSoftwareCompensation
    CmmSoftwareCompensationType CmmSoftwareCompensation() const { return _cmmSoftwareCompensationType; }
    void CmmSoftwareCompensation(CmmSoftwareCompensationType value) { _cmmSoftwareCompensationType = value; }

    // HasRotaryTable
    bool HasRotaryTable() const { return _hasRotaryTable; }
    void HasRotaryTable(bool value) { _hasRotaryTable = value; }

    // RotaryTableRadius
    double RotaryTableRadius() const { return _rotaryTableRadius; }
    void RotaryTableRadius(double value) { _rotaryTableRadius = value; }

    // RotaryTableXOrigin
    double RotaryTableXOrigin() const { return _rotaryTableXOrigin; }
    void RotaryTableXOrigin(double value) { _rotaryTableXOrigin = value; }

    // RotaryTableYOrigin
    double RotaryTableYOrigin() const { return _rotaryTableYOrigin; }
    void RotaryTableYOrigin(double value) { _rotaryTableYOrigin = value; }

    // RotaryTableZOrigin
    double RotaryTableZOrigin() const { return _rotaryTableZOrigin; }
    void RotaryTableZOrigin(double value) { _rotaryTableZOrigin = value; }

    // RotaryTableAxisDirection
    const std::vector<double>& RotaryTableAxisDirection() const { return _rotaryTableAxisDirection; }
    void RotaryTableAxisDirection(const std::vector<double>& value) { _rotaryTableAxisDirection = value; }

    // RotaryTableZeroIndexDirection
    const std::vector<double>& RotaryTableZeroIndexDirection() const { return _rotaryTableZeroIndexDirection; }
    void RotaryTableZeroIndexDirection(const std::vector<double>& value) { _rotaryTableZeroIndexDirection = value; }

    // RotaryTableAxialError
    double RotaryTableAxialError() const { return _rotaryTableAxialError; }
    void RotaryTableAxialError(double value) { _rotaryTableAxialError = value; }

    // RotaryTableRadialError
    double RotaryTableRadialError() const { return _rotaryTableRadialError; }
    void RotaryTableRadialError(double value) { _rotaryTableRadialError = value; }

    // RotaryTableTangentialError
    double RotaryTableTangentialError() const { return _rotaryTableTangentialError; }
    void RotaryTableTangentialError(double value) { _rotaryTableTangentialError = value; }

    // Adds a sensor to the list of Sensors at the end of the list.
    void AddSensor(SensorParameters* sensor);

    // Adds a sensor to the list of Sensors at the given index. Returns false if the index was out of bounds
    bool AddSensorAtIndex(size_t index, SensorParameters* sensor);

    // Removes a sensor from the list of Sensors. Returns true if the sensor was found in the list.
    bool RemoveSensor(SensorParameters* sensor);

    // Gets the description for this probe in the given units.
    std::wstring GetDescription(Units units);

    // Equals override
    bool operator==(const CmmParameters& other) const;

private:

    // Name
    std::wstring _name;
    // Origin (three-dimensional point)
    std::vector<double> _zero;
    // Extends (size == 3)
    std::vector<double> _extents;
    // Type of CMM
    CmmType _cmmType;
    // X-axis direction
    CmmAxisOrientation _cmmAxisOrientationX;
    // Y-axis direction
    CmmAxisOrientation _cmmAxisOrientationY;
    // Z-axis direction
    CmmAxisOrientation _cmmAxisOrientationZ;
    // Active performance test
    CmmPerformanceTest _activePerformanceTest;
    // ASME B89 performance test
    std::unique_ptr<CmmErrorB89> _b89Results;
    // ISO 10360 performance test
    std::unique_ptr<CmmErrorIso10360> _iso10360Results;
    // list of sensors
    std::vector<SensorParameters*> _sensors;

    // Type of scales
    CmmScalesType _cmmScalesType;
    // Temperature
    double _cmmTemperature;
    // Temperature uncertainty
    double _cmmTemperatureUncertainty;
    // Expansion coefficient
    double _cmmExpansionCoefficient;
    // Expansion coefficient uncertainty
    double _cmmExpansionCoefficientUncertainty;
    // Air temperature
    double _cmmLaserAirTemperature;
    // Air temperature uncertainty
    double _cmmLaserAirTemperatureUncertainty;
    // Air pressure
    double _cmmLaserAirPressure;
    // Air pressure uncertainty
    double _cmmLaserAirPressureUncertainty;
    // Air humidity
    double _cmmLaserAirHumidity;
    // Air humidity uncertainty
    double _cmmLaserAirHumidityUncertainty;
    // Software compensation type
    CmmSoftwareCompensationType _cmmSoftwareCompensationType;

    // Indicates whether CMM has a rotary table
    bool _hasRotaryTable;
    // Radius of rotary table
    double _rotaryTableRadius;
    // X-coordinate of rotary table origin
    double _rotaryTableXOrigin;
    // Y-coordinate of rotary table origin
    double _rotaryTableYOrigin;
    // Z-coordinate of rotary table origin
    double _rotaryTableZOrigin;
    // Axis direction of rotary table (three-dimensional vector)
    std::vector<double> _rotaryTableAxisDirection;
    // Zero index direction of rotary table
    std::vector<double> _rotaryTableZeroIndexDirection;
    // Axial error of rotary table
    double _rotaryTableAxialError;
    // Radial error of rotary table
    double _rotaryTableRadialError;
    // Tangential error of rotary table
    double _rotaryTableTangentialError;

};
}

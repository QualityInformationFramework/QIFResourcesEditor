///////////////////////////////////////////////////////////////////////////////
///
/// Copyright 2018-2020, Capvidia, Metrosage, and project contributors
/// https://www.capvidia.com/
/// 
/// This software is provided for free use to the QIF Community under the 
/// following license:
/// 
/// Boost Software License - Version 1.0 - August 17th, 2003
/// https://www.boost.org/LICENSE_1_0.txt
/// 
/// Permission is hereby granted, free of charge, to any person or organization
/// obtaining a copy of the software and accompanying documentation covered by
/// this license (the "Software") to use, reproduce, display, distribute,
/// execute, and transmit the Software, and to prepare derivative works of the
/// Software, and to permit third-parties to whom the Software is furnished to
/// do so, all subject to the following:
/// 
/// The copyright notices in the Software and this entire statement, including
/// the above license grant, this restriction and the following disclaimer,
/// must be included in all copies of the Software, in whole or in part, and
/// all derivative works of the Software, unless such copies or derivative
/// works are solely in the form of machine-executable object code generated by
/// a source language processor.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
/// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
/// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
/// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.

////////////////////////////////////////////////////////////////////////
//
// Altova.h
//
// This file was generated by XMLSpy 2016 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//
////////////////////////////////////////////////////////////////////////


#pragma once

#include "AltovaDefs.h"
#include <string>


#ifndef _MFC_VER
#pragma warning(disable: 4660)
#pragma warning(disable: 4231)
#pragma warning(disable: 4251)
#endif


#if defined(UNICODE) || defined(_UNICODE)
	#define tstring			std::wstring
	#define tstringstream	std::wstringstream
	#define tcin			std::wcin
	#define tcout			std::wcout
	#define tcerr			std::wcerr
	#define tclog			std::wclog
	#define tostream		std::wostream
	#define tofstream		std::wofstream
	#define tostringstream	std::wostringstream

	typedef std::wstring string_type;
#else
	#define tstring			std::string
	#define tstringstream	std::stringstream	
	#define tcin			std::cin
	#define tcout			std::cout
	#define tcerr			std::cerr
	#define tclog			std::clog
	#define tostream		std::ostream
	#define tofstream		std::ofstream
	#define tostringstream	std::ostringstream

	typedef std::string string_type;
#endif

typedef string_type::value_type char_type;


namespace altova {


////////////////////////////////////////////////////////////////////////
//
//  Utility functions
//
////////////////////////////////////////////////////////////////////////


#define ThrowFormatError() \
	throw CAltovaException(CAltovaException::eError1, _T("Format error"));

#define ThrowOutOfRangeError() \
	throw CAltovaException(CAltovaException::eError1, _T("Out of range!"));

#define ThrowIncompatibleTypesError() \
	throw CAltovaException(CAltovaException::eError1, _T("Types incompatible!"));

#define ThrowValuesNotConvertableError() \
	throw CAltovaException(CAltovaException::eError1, _T("Values are not convertable"));

#if defined( __GNUC__ )
	#define __int64 long long
	#define ALTOVA_INT64 long long 
    #define _I64_MIN LONG_LONG_MIN
    #define _I64_MAX LONG_LONG_MAX

#if defined(UNICODE) || defined(_UNICODE)
#define TCHAR       wchar_t
#define _T(x) 		L ## x

/* String conversion functions */

#define _tcstod     wcstod
#define _tcstol     wcstol
#define _tcstoul    wcstoul

/* String functions */

#define _tcscat     wcscat
#define _tcschr     wcschr
#define _tcscpy     wcscpy
#define _tcscspn    wcscspn
#define _tcslen     wcslen
#define _tcsncat    wcsncat
#define _tcsncpy    wcsncpy
#define _tcspbrk    wcspbrk
#define _tcsrchr    wcsrchr
#define _tcsspn     wcsspn
#define _tcsstr     wcsstr
#define _tcstok     wcstok

#define _tcscmp     wcscmp
#define _tcsnccmp   wcsncmp
#define _tcsncmp    wcsncmp

#define _tcscoll    wcscoll

#define _istspace   iswspace

#define _stscanf	swscanf
#define _totupper   towupper
#define _tfopen     altovawfopen
#else //NON UNICODE
#define TCHAR       char
#define _T(x) 		x

/* String conversion functions */

#define _tcstod     strtod
#define _tcstol     strtol
#define _tcstoul    strtoul

#define _tcschr     strchr
#define _tcscspn    strcspn
#define _tcsncat    strncat
#define _tcsncpy    strncpy
#define _tcspbrk    strpbrk
#define _tcsrchr    strrchr
#define _tcsspn     strspn
#define _tcsstr     strstr
#define _tcstok     strtok

#define _tcscmp     strcmp
#define _tcsnccmp   strncmp
#define _tcsncmp    strncmp

#define _tcscoll    strcoll

#define _istspace   isspace
#define _sntprintf  snprintf
#define _stscanf	sscanf
#define _totupper   toupper
#define _tfopen     fopen
#endif

#else
	#define ALTOVA_INT64 __int64
#endif

#ifdef _XERCES_VERSION

	#if defined(UNICODE) || defined(_UNICODE)
		#define XC2TS(x) x
	#else
		#define XC2TS(x) StrX(x).localForm()
	#endif

	class XStr
	{
	public:
		XStr(const char* const toTranscode) { m_bClone = true; fUnicodeForm = xercesc::XMLString::transcode(toTranscode); }
		XStr(const std::string& toTranscode) { m_bClone = true; fUnicodeForm = xercesc::XMLString::transcode(toTranscode.c_str()); }
		XStr(const wchar_t* const toTranscode) { m_bClone = false; fUnicodeForm = (XMLCh*)toTranscode; }
		XStr(const std::wstring& toTranscode) { m_bClone = false; fUnicodeForm = (XMLCh*)(toTranscode.c_str()); }
		~XStr() { if (m_bClone && fUnicodeForm) xercesc::XMLString::release(&fUnicodeForm); }
		const XMLCh* unicodeForm() const { return fUnicodeForm; }
	protected:
		bool m_bClone;
		XMLCh* fUnicodeForm;
	};

	class StrX
	{
	public:
		StrX(const XMLCh* const toTranscode) { fLocalForm = xercesc::XMLString::transcode(toTranscode); }
		~StrX() { xercesc::XMLString::release(&fLocalForm); }
		const char* localForm() const { return fLocalForm; }
	protected:
		char* fLocalForm;
	};

#endif

////////////////////////////////////////////////////////////////////////
//
//  CBaseObject
//
////////////////////////////////////////////////////////////////////////


class QIFBASE_EXPORT CBaseObject
{
public:
	virtual ~CBaseObject() {}
};

} // namespace altova

//#endif

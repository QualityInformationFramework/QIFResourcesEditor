///////////////////////////////////////////////////////////////////////////////
///
/// Copyright 2018-2020, Capvidia, Metrosage, and project contributors
/// https://www.capvidia.com/
/// 
/// This software is provided for free use to the QIF Community under the 
/// following license:
/// 
/// Boost Software License - Version 1.0 - August 17th, 2003
/// https://www.boost.org/LICENSE_1_0.txt
/// 
/// Permission is hereby granted, free of charge, to any person or organization
/// obtaining a copy of the software and accompanying documentation covered by
/// this license (the "Software") to use, reproduce, display, distribute,
/// execute, and transmit the Software, and to prepare derivative works of the
/// Software, and to permit third-parties to whom the Software is furnished to
/// do so, all subject to the following:
/// 
/// The copyright notices in the Software and this entire statement, including
/// the above license grant, this restriction and the following disclaimer,
/// must be included in all copies of the Software, in whole or in part, and
/// all derivative works of the Software, unless such copies or derivative
/// works are solely in the form of machine-executable object code generated by
/// a source language processor.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
/// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
/// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
/// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.

using System;
using System.Collections.Generic;
using System.Xml;
using System.Text.RegularExpressions;
using System.Linq;
using Qif;

namespace MeasurementResourceEditor.MrdXml
{
    /// <summary> Loader of MRD documents of version 0. </summary>
    internal class MrdXmlLoaderV0 : AMrdXmlLoader
    {
        #region Constructor

        /// <summary> Constructor. </summary>
        public MrdXmlLoaderV0(XmlDocument doc)
            : base(doc)
        {
        }
        #endregion

        #region ==== AMrdXmlLoader Implementation ====

        /// <summary> Loads a MRD file with version 0. </summary>
        /// <param name="rootElement"> The root element of the document </param>
        /// <returns> The list of CmmParameters loaded </returns>
        public override List<CmmParameters> Load(XmlElement rootElement)
        {
            List<CmmParameters> loadedCmms = new List<CmmParameters>();

            // Iterate through each CMM node
            XmlNodeList cmmNodes = rootElement.SelectNodes("Cmm");
            foreach (XmlNode cmmXmlNode in cmmNodes)
            {
                // Load the CMM node and add it to the list
                CmmParameters cmm = LoadCmmXmlNode(cmmXmlNode);
                loadedCmms.Add(cmm);
            }

            return loadedCmms;
        }
        #endregion

        #region ---- private load methods ----

        /// <summary> Load a CMM XML node, and populate a corresponding CmmParameters object. </summary>
        /// <param name="node"> The CMM XmlNode to load </param>
        /// <returns> A fully populated CmmParameters object that corresponds to the data in the node </returns>
        private CmmParameters LoadCmmXmlNode(XmlNode node)
        {
            CmmParameters cmmParameters = CmmParameters.CreateNewCmmParameters();

            // CMM Name
            cmmParameters.Name = GetSingleValue(node, "Name");

            // CMM Extents: Zero
            List<double> zero = new List<double>();
            zero.Add(GetSingleDAttributeValue(node, "Zero", "X"));
            zero.Add(GetSingleDAttributeValue(node, "Zero", "Y"));
            zero.Add(GetSingleDAttributeValue(node, "Zero", "Z"));
            cmmParameters.Zero = zero;

            // CMM Extents: Maximum Extents
            List<double> extents = new List<double>();
            extents.Add(GetSingleDAttributeValue(node, "Extents", "X"));
            extents.Add(GetSingleDAttributeValue(node, "Extents", "Y"));
            extents.Add(GetSingleDAttributeValue(node, "Extents", "Z"));
            cmmParameters.Extents = extents;

            // ActivePerformanceTest
            cmmParameters.ActivePerformanceTest = ToCmmPerformanceTest(GetSingleValue(node, "ActivePerformanceTest"));

            // B89 values
            cmmParameters.B89Results = LoadCmmB89XmlNode(node);

            // ISO 10360 values
            if (ContainsNode(node, "Iso10360"))
                throw new NotImplementedException("Iso10360 import not yet implemented");

            // Load a Rotary Table, if it is there
            LoadCmmRotaryTable(cmmParameters, node);

            // Load up new Sensors
            XmlNodeList sensorNodes = node.SelectNodes("Sensor");
            foreach (XmlNode sensorNode in sensorNodes)
            {
                SensorParameters sensor = LoadSensorXmlNode(sensorNode);
                cmmParameters.AddSensor(sensor);
            }

            return cmmParameters;
        }

        /// <summary> Will Load a B89 node and populate a CmmErrorB89 object with the values found. </summary>
        /// <param name="node"> The node that owns the B89 XmlNode we wish to load </param>
        /// <returns> A CmmErrorB89 object initialized to the loaded XML values </returns>
        private CmmErrorB89 LoadCmmB89XmlNode(XmlNode node)
        {
            // Open the StylusDefinitions node
            XmlNode b89Node = node.SelectSingleNode("B89");
            if (b89Node == null)
                return null;

            return new CmmErrorB89
            {
                XLinearAccuracy = GetSingleDValue(b89Node, "XLinearAccuracy"),
                YLinearAccuracy = GetSingleDValue(b89Node, "YLinearAccuracy"),
                ZLinearAccuracy = GetSingleDValue(b89Node, "ZLinearAccuracy"),
                OffsetVolumetricPerformance = GetSingleDValue(b89Node, "OffsetVolumetricPerformance"),
                VolumetricPerformance = GetSingleDValue(b89Node, "VolumetricPerformance"),
                Repeatability = GetSingleDValue(b89Node, "Repeatability")
            };
        }

        /// <summary> Loads a rotary table node if there is one in the given CMM node.  If not, sets the HasRotaryTable value to false. </summary>
        /// <param name="param"> A reference to the CmmParameters object we are building </param>
        /// <param name="node"> The CMM XmlNode </param>
        private void LoadCmmRotaryTable(CmmParameters param, XmlNode node)
        {
            // See if this CMM has a rotary table
            XmlNode rotaryTableNode = node.SelectSingleNode("RotaryTable");
            if (rotaryTableNode == null)
            {
                param.HasRotaryTable = false;
                return;
            }

            // This CMM has a rotary table, so load the values.  Start with radius and origin
            param.HasRotaryTable = true;
            param.RotaryTableRadius = GetSingleDValue(rotaryTableNode, "Radius");
            param.RotaryTableXOrigin = GetSingleDAttributeValue(rotaryTableNode, "Origin", "X");
            param.RotaryTableYOrigin = GetSingleDAttributeValue(rotaryTableNode, "Origin", "Y");
            param.RotaryTableZOrigin = GetSingleDAttributeValue(rotaryTableNode, "Origin", "Z");

            // Axis direction
            List<double> axisDirection = new List<double>();
            axisDirection.Add(GetSingleDAttributeValue(rotaryTableNode, "AxisDirection", "X"));
            axisDirection.Add(GetSingleDAttributeValue(rotaryTableNode, "AxisDirection", "Y"));
            axisDirection.Add(GetSingleDAttributeValue(rotaryTableNode, "AxisDirection", "Z"));
            if (IsValidRotaryTableAxisDirection(axisDirection))
                param.RotaryTableAxisDirection = axisDirection;
            else
                throw new ApplicationException("Invalid RotaryTable AxisDirection");

            // ZeroIndex Direction
            List<double> zeroIndexDirection = new List<double>();
            zeroIndexDirection.Add(GetSingleDAttributeValue(rotaryTableNode, "ZeroIndexDirection", "X"));
            zeroIndexDirection.Add(GetSingleDAttributeValue(rotaryTableNode, "ZeroIndexDirection", "Y"));
            zeroIndexDirection.Add(GetSingleDAttributeValue(rotaryTableNode, "ZeroIndexDirection", "Z"));
            if (IsValidUnitVector(zeroIndexDirection))
                param.RotaryTableZeroIndexDirection = zeroIndexDirection;
            else
                throw new ApplicationException("Invalid RotaryTable ZeroIndexDirection");

            // Error parameters
            param.RotaryTableAxialError = GetSingleDAttributeValue(rotaryTableNode, "Error", "Axial");
            param.RotaryTableRadialError = GetSingleDAttributeValue(rotaryTableNode, "Error", "Radial");
            param.RotaryTableTangentialError = GetSingleDAttributeValue(rotaryTableNode, "Error", "Tangential");
        }

        /// <summary> Loads a Sensor XML node, and populate a corresponding SensorParameters object. </summary>
        /// <param name="node"> The Sensor XmlNode to load </param>
        /// <returns> A fully populated SensorParameters object that corresponds to the data in the node </returns>
        private SensorParameters LoadSensorXmlNode(XmlNode node)
        {
            SensorParameters sensorParameters = SensorParameters.CreateNewSensorParameters();

            // Sensor Name
            sensorParameters.Name = GetSingleValue(node, "Name");

            // SensorType
            sensorParameters.Type = ToSensorType(GetSingleValue(node, "SensorType"));

            // SensorTechnology
            sensorParameters.Technology = ToSensorTechnology(GetSingleValue(node, "SensorTechnology"));

            // ActivePerformanceTest
            sensorParameters.ActivePerformanceTest = ToSensorPerformanceTest(GetSingleValue(node, "ActivePerformanceTest"));

            // Get the performance test data.
            sensorParameters.PerformanceTestIso10360 = GetSingleDValueList(node, "Iso10360");
            sensorParameters.PerformanceTestB89 = GetSingleDValueList(node, "B89");
            sensorParameters.PerformanceTestVdiVde = GetSingleDValueList(node, "VdiVde");
            sensorParameters.PerformanceTestSpecifiedStandardDeviation = GetSingleDValueList(node, "SpecifiedStandardDeviation");

            // Get the stylus lengths
            sensorParameters.StylusLengths = LoadStylusDefinitionsXmlNode(node);

            // Get the extension length
            sensorParameters.ExtensionLength = GetSingleDAttributeValue(node, "Extension", "Length");

            return sensorParameters;
        }

        /// <summary> Loads up the stylus lengths from the given StylusDefinitions node. </summary>
        /// <param name="node"> The node that owns the StylusDefinitions node we wish to load </param>
        /// <returns> A list of doubles contained in the StylusDefinitions node </returns>
        private List<double> LoadStylusDefinitionsXmlNode(XmlNode node)
        {
            // Open the StylusDefinitions node
            XmlNode stylusDefinitionsNode = node.SelectSingleNode("StylusDefinitions");
            if (stylusDefinitionsNode == null)
                throw new ApplicationException("No StylusDefinitions found.");

            // Loop through each Stylus node within the StylusDefinitions
            List<double> stylusLengths = new List<double>();
            XmlNodeList stylusNodes = stylusDefinitionsNode.SelectNodes("Stylus");
            foreach (XmlNode stylusNode in stylusNodes)
            {
                XmlAttributeCollection attributes = stylusNode.Attributes;
                if (attributes != null)
                {
                    XmlNode attributeNode = attributes.GetNamedItem("Length");
                    if (attributeNode != null)
                    {
                        if (!Utilities.TryParseDouble(attributeNode.Value, out var length))
                            throw new ApplicationException("Error parsing value: " + attributeNode.Value + " in <StylusDefinitions>");
                        stylusLengths.Add(length);
                    }
                }
            }
            return stylusLengths;
        }
        #endregion

        #region ---- private value verification methods ----

        /// <summary> Determines if the given value is a valid unit vector. </summary>
        /// <param name="vector"> Vector to check </param>
        /// <returns> True if the vector is valid, otherwise false </returns>
        private bool IsValidUnitVector(List<double> vector)
        {
            // There must be 3 values
            if (vector.Count != 3)
                return false;

            // Values must add up to one
            double sum = vector[0] + vector[1] + vector[2];
            if (sum == 1)
                return true;
            return false;
        }

        /// <summary> Determines if the given list of doubles is a valid Rotary Table Axis Direction. </summary>
        /// <param name="axisDirection"> The list of doubles to check </param>
        /// <returns> True if value is valid </returns>
        private bool IsValidRotaryTableAxisDirection(List<double> axisDirection)
        {
            // There must be 3 values
            if (axisDirection.Count != 3)
                return false;

            // The vector must be orthogonal to an axis direction.  So must be 1,0,0 or 0,1,0 or 0,0,1
            if (Math.Abs(axisDirection[0]) == 1)
                if (axisDirection[1] != 0 && axisDirection[2] != 0)
                    return false;
            if (Math.Abs(axisDirection[1]) == 1)
                if (axisDirection[0] != 0 && axisDirection[2] != 0)
                    return false;
            if (Math.Abs(axisDirection[2]) == 1)
                if (axisDirection[0] != 0 && axisDirection[1] != 0)
                    return false;

            return true;
        }
        #endregion

        #region ---- private conversion methods ----

        /// <summary> Converts the given string to a Cmm.PerformanceTest enumeration. </summary>
        /// <param name="value"> The string to convert </param>
        /// <returns> The corresponding Cmm.PerformanceTest </returns>
        CmmPerformanceTest ToCmmPerformanceTest(string value)
        {
            switch (value)
            {
                case "B89":
                    return CmmPerformanceTest.B89;
                case "Iso10360":
                    return CmmPerformanceTest.Iso10360;
            }
            return CmmPerformanceTest.None;
        }

        /// <summary> Converts the given string to a Sensor.Type enumeration. </summary>
        /// <param name="value"> The string to convert </param>
        /// <returns> The corresponding Sensor.Type </returns>
        SensorType ToSensorType(string value)
        {
            switch (value)
            {
                case "SingleTipFixed":
                    return SensorType.SingleTipFixed;
                case "SingleTipArticulated":
                    return SensorType.SingleTipArticulated;
                case "MultiTipFixed":
                    return SensorType.MultiTipFixed;
            }
            return SensorType.SingleTipFixed;
        }

        /// <summary> Converts the given string to a Sensor.Technology enumeration. </summary>
        /// <param name="value"> The string to convert </param>
        /// <returns> The corresponding Sensor.Technology </returns>
        SensorTechnology ToSensorTechnology(string value)
        {
            if (value == "PiezoelectricProbe")
                return SensorTechnology.PiezoelectricProbe;

            return SensorTechnology.SwitchingProbe;
        }

        /// <summary> Converts the given string to a Sensor.PerformanceTest enumeration. </summary>
        /// <param name="value"> The string to convert </param>
        /// <returns> The corresponding Sensor.PerformanceTest </returns>
        SensorPerformanceTest ToSensorPerformanceTest(string value)
        {
            switch (value)
            {
                case "Iso10360":
                    return SensorPerformanceTest.Iso10360;
                case "B89":
                    return SensorPerformanceTest.B89;
                case "VdiVde":
                    return SensorPerformanceTest.VdiVde;
                case "SpecifiedStandardDeviation":
                    return SensorPerformanceTest.SpecifiedStandardDeviation;
            }
            return SensorPerformanceTest.None;
        }
        #endregion
    }
}

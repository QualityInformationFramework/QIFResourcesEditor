// Copyright(c) Capvidia, 2020
// https://www.capvidia.com
//
// Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software
// and accompanying documentation covered by this license(the "Software") to use, reproduce, display, distribute, execute,
// and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the Software
// is furnished to do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement,
// including the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and all derivative works of the Software,
// unless such copies or derivative works are solely in the form of machine-executable object code generated by a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT.
// IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#pragma once
#include "CmmType.h"
#include "CmmAxisOrientation.h"
#include "CmmPerformanceTest.h"
#include "CmmErrorB89.h"
#include "CmmErrorIso10360.h"
#include "SensorParameters.h"
#include "CmmScalesType.h"
#include "CmmSoftwareCompensationType.h"
#include "Units.h"
#include <qifbase/Data/CmmParameters.h>

using System::String;
using System::Collections::Generic::IReadOnlyList;
using System::Collections::Generic::List;

namespace Qif
{
/// <summary> Represents a CMM. </summary>
public ref class CmmParameters
{
public:
    // Constructor 
    CmmParameters(qifbase::CmmParameters* cmmParameters);

    // "Copy" Constructor
    CmmParameters(CmmParameters^ cmmParameters);

    // Finalizer & Destructor
    ~CmmParameters() { this->!CmmParameters(); }
    !CmmParameters();

    // Calls delete on the native data that this class wraps. We don't rely on GC for this layer
    void DeleteNativeData();

    // Creates a new, default CmmParameters object, including a new underlying native object.
    static CmmParameters^ CreateNewCmmParameters();

    // Creates a new CmmParameters object, including a new underlying native object, based on the given CmmParameters
    static CmmParameters^ CreateNewCmmParameters(CmmParameters^ copyFrom);

private:
    // Default Constructor. Private: call CreateNewSensorParameters() instead.
    CmmParameters();

    // "Copy" constructor. Copies underlying value as well. Private: call CreateNewSensorParameters() instead.
    CmmParameters(const qifbase::CmmParameters& cmmParameters);

public:

    // Name
    property String^ Name
    {
        String^ get();
        void set(String^ value);
    }

    // Origin (three-dimensional point)
    property IReadOnlyList<double>^ Zero
    {
        IReadOnlyList<double>^ get();
        void set(IReadOnlyList<double>^ value);
    }

    //  Extends (Count == 3)
    property IReadOnlyList<double>^ Extents
    {
        IReadOnlyList<double>^ get();
        void set(IReadOnlyList<double>^ value);
    }

    // Type
    property CmmType Type
    {
        CmmType get() { return (CmmType)_data->Type(); }
        void set(CmmType value) { _data->Type((qifbase::CmmType)value); }
    }

    // X-axis direction
    property CmmAxisOrientation AxisOrientationX
    {
        CmmAxisOrientation get() { return (CmmAxisOrientation)_data->AxisOrientationX(); }
        void set(CmmAxisOrientation value) { _data->AxisOrientationX((qifbase::CmmAxisOrientation)value); }
    }

    // Y-axis direction
    property CmmAxisOrientation AxisOrientationY
    {
        CmmAxisOrientation get() { return (CmmAxisOrientation)_data->AxisOrientationY(); }
        void set(CmmAxisOrientation value) { _data->AxisOrientationY((qifbase::CmmAxisOrientation)value); }
    }

    // Z-axis direction
    property CmmAxisOrientation AxisOrientationZ
    {
        CmmAxisOrientation get() { return (CmmAxisOrientation)_data->AxisOrientationZ(); }
        void set(CmmAxisOrientation value) { _data->AxisOrientationZ((qifbase::CmmAxisOrientation)value); }
    }

    // Active performance test
    property CmmPerformanceTest ActivePerformanceTest
    {
        CmmPerformanceTest get() { return (CmmPerformanceTest)_data->ActivePerformanceTest(); }
        void set(CmmPerformanceTest value) { _data->ActivePerformanceTest((qifbase::CmmPerformanceTest)value); }
    }

    // ASME B89 performance test
    property CmmErrorB89^ B89Results
    {
        CmmErrorB89^ get();
        void set(CmmErrorB89^ value);
    }

    // ISO 10360 performance test
    property CmmErrorIso10360^ Iso10360Results
    {
        CmmErrorIso10360^ get();
        void set(CmmErrorIso10360^ value);
    }

    // List of sensors
    property IReadOnlyList<SensorParameters^>^ SensorParameterList
    {
        IReadOnlyList<SensorParameters^>^ get();
    }

    // Type of scales
    property CmmScalesType CmmScales
    {
        CmmScalesType get() { return (CmmScalesType)_data->CmmScales(); }
        void set(CmmScalesType value) { _data->CmmScales((qifbase::CmmScalesType)value); }
    }

    // Temperature
    property double CmmTemperature
    {
        double get() { return _data->CmmTemperature(); }
        void set(double value) { _data->CmmTemperature(value); }
    }

    // Temperature uncertainty
    property double CmmTemperatureUncertainty
    {
        double get() { return _data->CmmTemperatureUncertainty(); }
        void set(double value) { _data->CmmTemperatureUncertainty(value); }
    }

    // Expansion coefficient
    property double CmmExpansionCoefficient
    {
        double get() { return _data->CmmExpansionCoefficient(); }
        void set(double value) { _data->CmmExpansionCoefficient(value); }
    }

    // Expansion coefficient uncertainty
    property double CmmExpansionCoefficientUncertainty
    {
        double get() { return _data->CmmExpansionCoefficientUncertainty(); }
        void set(double value) { _data->CmmExpansionCoefficientUncertainty(value); }
    }

    // Air temperature
    property double CmmLaserAirTemperature
    {
        double get() { return _data->CmmLaserAirTemperature(); }
        void set(double value) { _data->CmmLaserAirTemperature(value); }
    }

    // Air temperature uncertainty
    property double CmmLaserAirTemperatureUncertainty
    {
        double get() { return _data->CmmLaserAirTemperatureUncertainty(); }
        void set(double value) { _data->CmmLaserAirTemperatureUncertainty(value); }
    }

    // Air pressure
    property double CmmLaserAirPressure
    {
        double get() { return _data->CmmLaserAirPressure(); }
        void set(double value) { _data->CmmLaserAirPressure(value); }
    }

    //  Air pressure uncertainty
    property double CmmLaserAirPressureUncertainty
    {
        double get() { return _data->CmmLaserAirPressureUncertainty(); }
        void set(double value) { _data->CmmLaserAirPressureUncertainty(value); }
    }

    // Air humidity
    property double CmmLaserAirHumidity
    {
        double get() { return _data->CmmLaserAirHumidity(); }
        void set(double value) { _data->CmmLaserAirHumidity(value); }
    }

    // Air humidity uncertainty
    property double CmmLaserAirHumidityUncertainty
    {
        double get() { return _data->CmmLaserAirHumidityUncertainty(); }
        void set(double value) { _data->CmmLaserAirHumidityUncertainty(value); }
    }

    // Software compensation type
    property CmmSoftwareCompensationType CmmSoftwareCompensation
    {
        CmmSoftwareCompensationType get() { return (CmmSoftwareCompensationType)_data->CmmSoftwareCompensation(); }
        void set(CmmSoftwareCompensationType value) { _data->CmmSoftwareCompensation((qifbase::CmmSoftwareCompensationType)value); }
    }

    // Indicates whether CMM has a rotary table
    property bool HasRotaryTable
    {
        bool get() { return _data->HasRotaryTable(); }
        void set(bool value) { _data->HasRotaryTable(value); }
    }

    // Radius of rotary table
    property double RotaryTableRadius
    {
        double get() { return _data->RotaryTableRadius(); }
        void set(double value) { _data->RotaryTableRadius(value); }
    }

    // X-coordinate of rotary table origin
    property double RotaryTableXOrigin
    {
        double get() { return _data->RotaryTableXOrigin(); }
        void set(double value) { _data->RotaryTableXOrigin(value); }
    }

    // Y-coordinate of rotary table origin
    property double RotaryTableYOrigin
    {
        double get() { return _data->RotaryTableYOrigin(); }
        void set(double value) { _data->RotaryTableYOrigin(value); }
    }

    //  Z-coordinate of rotary table origin
    property double RotaryTableZOrigin
    {
        double get() { return _data->RotaryTableZOrigin(); }
        void set(double value) { _data->RotaryTableZOrigin(value); }
    }

    // Axis direction of rotary table (three-dimensional vector)
    property IReadOnlyList<double>^ RotaryTableAxisDirection
    {
        IReadOnlyList<double>^ get();
        void set(IReadOnlyList<double>^ value);
    }

    // Zero index direction of rotary table
    property IReadOnlyList<double>^ RotaryTableZeroIndexDirection
    {
        IReadOnlyList<double>^ get();
        void set(IReadOnlyList<double>^ value);
    }

    //  Axial error of rotary table
    property double RotaryTableAxialError
    {
        double get() { return _data->RotaryTableAxialError(); }
        void set(double value) { _data->RotaryTableAxialError(value); }
    }

    // Radial error of rotary table
    property double RotaryTableRadialError
    {
        double get() { return _data->RotaryTableRadialError(); }
        void set(double value) { _data->RotaryTableRadialError(value); }
    }

    // Tangential error of rotary table
    property double RotaryTableTangentialError
    {
        double get() { return _data->RotaryTableTangentialError(); }
        void set(double value) { _data->RotaryTableTangentialError(value); }
    }

    // Pointer to the internal data
    property qifbase::CmmParameters* InternalData
    {
        qifbase::CmmParameters* get() { return _data; }
    }

    // Add a new sensor to the list of sensors
    void AddSensor(SensorParameters^ sensor);

    // Adds a sensor to the list of Sensors at the given index. Returns false if the index was out of bounds
    bool AddSensorAtIndex(size_t index, SensorParameters^ sensor);

    // Removes the given sensor from the list of sensors. Returns true if this sensor was found in the list and then erased.
    bool RemoveSensor(SensorParameters^ sensor);

    // Removes all sensors
    void ClearSensorList();

    // Gets the description for this probe in the given units.
    String^ GetDescription(Units units);

    // Equals override
    virtual bool Equals(Object^ o) override;

    // ToString override
    virtual String^ ToString() override;

    // Indicates checks pointer equality of the internal fields
    bool ReferenceEquality(CmmParameters^ other) { return _data == other->_data; }

protected:
    // core unmanaged object
    qifbase::CmmParameters* _data;
};
}

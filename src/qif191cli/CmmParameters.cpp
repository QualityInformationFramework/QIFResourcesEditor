///////////////////////////////////////////////////////////////////////////////
///
/// Copyright 2018-2020, Capvidia, Metrosage, and project contributors
/// https://www.capvidia.com/
/// 
/// This software is provided for free use to the QIF Community under the 
/// following license:
/// 
/// Boost Software License - Version 1.0 - August 17th, 2003
/// https://www.boost.org/LICENSE_1_0.txt
/// 
/// Permission is hereby granted, free of charge, to any person or organization
/// obtaining a copy of the software and accompanying documentation covered by
/// this license (the "Software") to use, reproduce, display, distribute,
/// execute, and transmit the Software, and to prepare derivative works of the
/// Software, and to permit third-parties to whom the Software is furnished to
/// do so, all subject to the following:
/// 
/// The copyright notices in the Software and this entire statement, including
/// the above license grant, this restriction and the following disclaimer,
/// must be included in all copies of the Software, in whole or in part, and
/// all derivative works of the Software, unless such copies or derivative
/// works are solely in the form of machine-executable object code generated by
/// a source language processor.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
/// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
/// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
/// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.

#include "stdafx.h"
#include "CmmParameters.h"
#include <msclr\marshal.h>
#include <msclr\marshal_cppstd.h>
#define ss2ws(x) msclr::interop::marshal_as<std::wstring>(x)

namespace Qif
{
/// <summary> Constructor. Initializes an object that refers to he specified core data. </summary>
/// <param name="cmmParameters"> Core CMM object </param>
CmmParameters::CmmParameters(qifbase::CmmParameters* cmmParameters)
{
    _data = cmmParameters;
}

/// <summary> Constructor. Initializes an object that refers to the same data as the specified one. </summary>
/// <param name="cmmParameters"> CMM object </param>
CmmParameters::CmmParameters(CmmParameters^ cmmParameters)
{
    _data = cmmParameters->_data;
}

/// <summary> Finalizer. </summary>
CmmParameters::!CmmParameters()
{
}

/// <summary> Calls delete on the native data that this class wraps. We don't rely on GC for this layer. </summary>
void CmmParameters::DeleteNativeData()
{
    delete _data;
}

/// <summary> Creates a new, default CmmParameters object, including a new underlying native object. </summary>
/// <returns> Created object </returns>
CmmParameters^ CmmParameters::CreateNewCmmParameters()
{
    return gcnew CmmParameters();
}

/// <summary> Creates a new object and copies data from the specified object. </summary>
/// <param name="copyFrom"> Source object </param>
/// <returns> Copy object </returns>
CmmParameters^ CmmParameters::CreateNewCmmParameters(CmmParameters^ copyFrom)
{
    return gcnew CmmParameters(*(copyFrom->InternalData));
}

/// <summary> Constructor. </summary>
CmmParameters::CmmParameters()
{
    _data = new qifbase::CmmParameters();
}

/// <summary> Constructor. Initializes a new object copying data from the specified core object. </summary>
/// <param name="cmmParameters"> Object to copy </param>
CmmParameters::CmmParameters(const qifbase::CmmParameters& cmmParameters)
{
    _data = new qifbase::CmmParameters(cmmParameters);
}


/// <summary> Compares the object with the given one. </summary>
/// <param name="o"> Object to compare </param>
/// <returns> True if objects are equal, otherwise false </returns>
bool CmmParameters::Equals(Object^ o)
{
    CmmParameters^ other = dynamic_cast<CmmParameters^>(o);
    if(other == nullptr)
        return false;

    return (*_data == *(other->_data));
}

/// <summary> Gets string representation of the object. </summary>
/// <returns> String </returns>
String^ CmmParameters::ToString()
{
    String^ s = Name;
#ifdef _DEBUG
    s += " _data = " + System::String::Format("0x{0:x}", (long long)_data);
#endif
    return s;
}

/// <summary> Gets the description for this CMM in the given units. </summary>
/// <param name="units"> Units </param>
/// <returns> Description </returns>
String^ CmmParameters::GetDescription(Units units)
{
    return gcnew String(_data->GetDescription((qifbase::Units)units).c_str());
}

/// <summary> Gets name. </summary>
String^ CmmParameters::Name::get()
{
    return gcnew String(_data->Name().c_str());
}

/// <summary> Sets name. </summary>
void CmmParameters::Name::set(String^ value)
{
    if(value != nullptr)
        _data->Name(ss2ws(value));
    else
        _data->Name(L"");
}

/// <summary> Gets zero. </summary>
IReadOnlyList<double>^ CmmParameters::Zero::get()
{
    return ToDoubleList(_data->Zero());
}

/// <summary> Sets zero. </summary>
void CmmParameters::Zero::set(IReadOnlyList<double>^ value)
{
    std::vector<double> v;
    ToDoubleVector(value, v);
    _data->Zero(v);
}


/// <summary> Gets extents. </summary>
IReadOnlyList<double>^ CmmParameters::Extents::get()
{
    return ToDoubleList(_data->Extents());
}

/// <summary> Sets extents. </summary>
void CmmParameters::Extents::set(IReadOnlyList<double>^ value)
{
    std::vector<double> v;
    ToDoubleVector(value, v);
    _data->Extents(v);
}


/// <summary> Gets ASME B89 performance test. </summary>
CmmErrorB89^ CmmParameters::B89Results::get()
{
    return gcnew CmmErrorB89((qifbase::CmmErrorB89&)*_data->B89Results());
}

/// <summary> Sets ASME B89 performance test. </summary>
void CmmParameters::B89Results::set(CmmErrorB89^ value)
{
    if(value != nullptr)
        _data->B89Results(value->InternalData);
    else
        _data->B89Results(new qifbase::CmmErrorB89());
}


/// <summary> Gets ISO 10360 performance test. </summary>
CmmErrorIso10360^ CmmParameters::Iso10360Results::get()
{
    return gcnew CmmErrorIso10360((qifbase::CmmErrorIso10360&)*_data->Iso10360Results());
}

/// <summary> Sets ISO 10360 performance test. </summary>
void CmmParameters::Iso10360Results::set(CmmErrorIso10360^ value)
{
    if(value != nullptr)
        _data->Iso10360Results(value->InternalData);
    else
        _data->Iso10360Results(&(qifbase::CmmErrorIso10360()));
}


/// <summary> Gets axis direction of rotary table. </summary>
IReadOnlyList<double>^ CmmParameters::RotaryTableAxisDirection::get()
{
    return ToDoubleList(_data->RotaryTableAxisDirection());
}

/// <summary> Sets axis direction of rotary table. </summary>
void CmmParameters::RotaryTableAxisDirection::set(IReadOnlyList<double>^ value)
{
    std::vector<double> v;
    ToDoubleVector(value, v);
    _data->RotaryTableAxisDirection(v);
}


/// <summary> Gets zero index direction of rotary table. </summary>
IReadOnlyList<double>^ CmmParameters::RotaryTableZeroIndexDirection::get()
{
    return ToDoubleList(_data->RotaryTableZeroIndexDirection());
}

/// <summary> Sets zero index direction of rotary table. </summary>
void CmmParameters::RotaryTableZeroIndexDirection::set(IReadOnlyList<double>^ value)
{
    std::vector<double> v;
    ToDoubleVector(value, v);
    _data->RotaryTableZeroIndexDirection(v);
}

/// <summary> Gets list of sensor indetifiers. </summary>
IReadOnlyList<SensorParameters^>^ CmmParameters::SensorParameterList::get()
{
    List<SensorParameters^>^ list = gcnew List<SensorParameters^>();
    for(size_t i = 0; i < _data->Sensors().size(); i++)
        list->Add(gcnew SensorParameters(_data->Sensors()[i]));
    return list;
}

/// <summary> Adds a new sensor to the list of sensors. </summary>
/// <param name="sensor"> Sensor to add </param>
void CmmParameters::AddSensor(SensorParameters^ sensor)
{
    _data->AddSensor(sensor->InternalData);
}

/// <summary>
/// Adds a sensor to the list of Sensors at the given index.
/// Returns null if the index was out of bounds, and the sensor not inserted.
/// </summary>
/// <param name="index"> Index </param>
/// <param name="sensor"> Sensor to add </param>
/// <returns> False if the index was out of bounds, and the sensor not inserted. Otherwise returns true. </returns>
bool CmmParameters::AddSensorAtIndex(size_t index, SensorParameters^ sensor)
{
    return _data->AddSensorAtIndex(index, sensor->InternalData);
}

/// <summary> Removes a sensor from the list of Sensors.  </summary>
/// <param name="sensor"> Sensor to remove </param>
/// <returns> Returns true if the sensor was found and removed from the list. </returns>
bool CmmParameters::RemoveSensor(SensorParameters^ sensor)
{
    bool result = _data->RemoveSensor(sensor->InternalData);
    return result;
}

/// <summary> Removes all sensors. </summary>
void CmmParameters::ClearSensorList()
{
    std::vector<qifbase::SensorParameters*> emptyList;
    _data->Sensors(emptyList);
}
}

///////////////////////////////////////////////////////////////////////////////
///
/// Copyright 2018-2020, Capvidia, Metrosage, and project contributors
/// https://www.capvidia.com/
/// 
/// This software is provided for free use to the QIF Community under the 
/// following license:
/// 
/// Boost Software License - Version 1.0 - August 17th, 2003
/// https://www.boost.org/LICENSE_1_0.txt
/// 
/// Permission is hereby granted, free of charge, to any person or organization
/// obtaining a copy of the software and accompanying documentation covered by
/// this license (the "Software") to use, reproduce, display, distribute,
/// execute, and transmit the Software, and to prepare derivative works of the
/// Software, and to permit third-parties to whom the Software is furnished to
/// do so, all subject to the following:
/// 
/// The copyright notices in the Software and this entire statement, including
/// the above license grant, this restriction and the following disclaimer,
/// must be included in all copies of the Software, in whole or in part, and
/// all derivative works of the Software, unless such copies or derivative
/// works are solely in the form of machine-executable object code generated by
/// a source language processor.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
/// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
/// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
/// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.

#include "stdafx.h"
#include "SensorParameters.h"
#include <msclr\marshal.h>
#include <msclr\marshal_cppstd.h>
#define ss2ws(x) msclr::interop::marshal_as<std::wstring>(x)

namespace Qif
{

/// <summary> Constructor. Initializes a new object that refers to the specified core sensor object. </summary>
/// <param name="sensorParameters"> Core sensor object </param>
SensorParameters::SensorParameters(qifbase::SensorParameters* sensorParameters)
{
    _data = sensorParameters;
}

/// <summary> Constructor. Initializes a new object that refers to the same core data as the specified object. </summary>
/// <param name="sensorParameters"> Sensor object </param>
SensorParameters::SensorParameters(SensorParameters^ sensorParameters)
{
    _data = sensorParameters->_data;
}

/// <summary> Finalizer </summary>
/// <returns></returns>
SensorParameters::!SensorParameters()
{
}

/// <summary> Calls delete on the native data that this class wraps. We don't rely on GC for this layer. </summary>
void SensorParameters::DeleteNativeData()
{
    delete _data;
}

/// <summary> Gets hash code of the object. </summary>
/// <returns> Hash code </returns>
int SensorParameters::GetHashCode()
{
    return ((long long)_data).GetHashCode();
}

/// <summary> Creates a new, default SensorParameters object, including a new underlying native object. </summary>
/// <returns> Created object </returns>
SensorParameters^ SensorParameters::CreateNewSensorParameters()
{
    return gcnew SensorParameters();
}

/// <summary> Creates a new sensor object copying data from the specified one. </summary>
/// <param name="copyFrom"> Object to copy </param>
/// <returns> Created object </returns>
SensorParameters^ SensorParameters::CreateNewSensorParameters(SensorParameters^ copyFrom)
{
    return gcnew SensorParameters(*(copyFrom->InternalData));
}

/// <summary> Constructor. </summary>
SensorParameters::SensorParameters()
{
    _data = new qifbase::SensorParameters();
}

/// <summary> Constructor. Initializes a new object copying data from the specified core sensor object. </summary>
/// <param name="sensorParameters"> Core sensor copy </param>
SensorParameters::SensorParameters(const qifbase::SensorParameters& sensorParameters)
{
    _data = new qifbase::SensorParameters(sensorParameters);
}

/// <summary> Compares the object with the given one. </summary>
/// <param name="o"> Object to compare </param>
/// <returns> True if objects are equal, otherwise false </returns>
bool SensorParameters::Equals(Object^ o)
{
    auto other = dynamic_cast<SensorParameters^>(o);
    if(other == nullptr)
        return false;

    return (*_data == *(other->_data));
}

/// <summary> Gets a string representation of the sensor. </summary>
/// <returns> String </returns>
String^ SensorParameters::ToString()
{
    String^ s = Name;
#ifdef _DEBUG
    s += " _data = " + System::String::Format("0x{0:x}", (long long)_data);
#endif
    return s;
}

/// <summary> Gets the description for this probe in the given units. </summary>
/// <param name="units"> Units </param>
/// <returns> String description </returns>
String^ SensorParameters::GetDescription(Units units)
{
    std::wstring ws = _data->GetDescription((qifbase::Units)units);
    return gcnew String(ws.c_str());
}

/// <summary> Gets the name. </summary>
String^ SensorParameters::Name::get()
{
    return gcnew String(_data->Name().c_str());
}

/// <summary> Sets the name. </summary>
void SensorParameters::Name::set(String^ value)
{
    if(value != nullptr)
        _data->Name(ss2ws(value));
    else
        _data->Name(L"");
}


/// <summary> Gets the ISO 10360 performance test values. </summary>
IReadOnlyList<double>^ SensorParameters::PerformanceTestIso10360::get()
{
    return ToDoubleList(_data->PerformanceTestIso10360());
}

/// <summary> Sets the ISO 10360 performance test values. </summary>
void SensorParameters::PerformanceTestIso10360::set(IReadOnlyList<double>^ value)
{
    std::vector<double> v;
    ToDoubleVector(value, v);
    _data->PerformanceTestIso10360(v);
}

/// <summary> Gets the ASME B89 performance test values. </summary>
IReadOnlyList<double>^ SensorParameters::PerformanceTestB89::get()
{
    return ToDoubleList(_data->PerformanceTestB89());
}

/// <summary> Sets the ASME B89 performance test values. </summary>
void SensorParameters::PerformanceTestB89::set(IReadOnlyList<double>^ value)
{
    std::vector<double> v;
    ToDoubleVector(value, v);
    _data->PerformanceTestB89(v);
}

/// <summary> Gets the VDI/VDE performance test values. </summary>
IReadOnlyList<double>^ SensorParameters::PerformanceTestVdiVde::get()
{
    return ToDoubleList(_data->PerformanceTestVdiVde());
}

/// <summary> Sets the VDI/VDE performance test values. </summary>
void SensorParameters::PerformanceTestVdiVde::set(IReadOnlyList<double>^ value)
{
    std::vector<double> v;
    ToDoubleVector(value, v);
    _data->PerformanceTestVdiVde(v);
}

/// <summary> Gets the specified standard deviation performance test values. </summary>
IReadOnlyList<double>^ SensorParameters::PerformanceTestSpecifiedStandardDeviation::get()
{
    return ToDoubleList(_data->PerformanceTestSpecifiedStandardDeviation());
}

/// <summary> Sets the specified standard deviation performance test values. </summary>
void SensorParameters::PerformanceTestSpecifiedStandardDeviation::set(IReadOnlyList<double>^ value)
{
    std::vector<double> v;
    ToDoubleVector(value, v);
    _data->PerformanceTestSpecifiedStandardDeviation(v);
}

/// <summary> Gets the stylus lengths. </summary>
IReadOnlyList<double>^ SensorParameters::StylusLengths::get()
{
    return ToDoubleList(_data->StylusLengths());
}

/// <summary> Sets the stylus lengths. </summary>
void SensorParameters::StylusLengths::set(IReadOnlyList<double>^ value)
{
    std::vector<double> v;
    ToDoubleVector(value, v);
    _data->StylusLengths(v);
}
}

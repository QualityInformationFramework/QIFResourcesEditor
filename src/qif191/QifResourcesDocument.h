// Copyright(c) Capvidia, 2020
// https://www.capvidia.com
//
// Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software
// and accompanying documentation covered by this license(the "Software") to use, reproduce, display, distribute, execute,
// and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the Software
// is furnished to do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement,
// including the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and all derivative works of the Software,
// unless such copies or derivative works are solely in the form of machine-executable object code generated by a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT.
// IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#pragma once
#include "decl_qif.h"
#include "QIFDocument/QIFDocument.h"
#include <qifbase/AQifResourcesDocument.h>
#include <string>
#include <map>

namespace qif191
{
class CmmMapping;

/// <summary> QIF 1.9.1 resources document. </summary>
class QIF191_EXPORT QifResourcesDocument : public qifbase::AQifResourcesDocument
{
public:
    QifResourcesDocument(std::wstring path);

    // Saves the given CMM list to the QIF document. Returns true if success.
    bool Save(const std::vector<std::unique_ptr<qifbase::CmmParameters> >& cmmParameters) override;

    // Loads a list of CMMs from the QIF document. Returns true if success.
    bool Load(std::vector<std::unique_ptr<qifbase::CmmParameters> >& cmmList) override;

    // Error and Warning lists
    const std::vector<std::wstring>& ErrorList() override { return _errorList; }
    const std::vector<std::wstring>& ErrorDetailsList() override { return _errorDetailsList; }
    const std::vector<std::wstring>& WarningList() override { return _warningList; }
    const std::vector<std::wstring>& WarningDetailsList() override { return _warningDetailsList; }

    // Returns true if there was an error/warning
    bool HadError() override { return (_errorList.empty() != true); }
    bool HadWarning() override { return (_warningList.empty() != true); }

private:
    // Saves the given CMM list to the QIF document. Private method that actually carries out the bulk of the work.
    bool DoSave(qif191::t::CQIFDocument& document, const std::vector<std::unique_ptr<qifbase::CmmParameters> >& cmmParameters);

    // Adds a probe to the given sensor root of a QIF document. Returns the QIF ID of the probe that was created.
    void AddProbe(qif191::t::CSensorsType& sensorsRoot, const qifbase::SensorParameters& probeParameters, unsigned& newSensorId);

    // Adds the given CMM Parameters with the attached sensors to the QIF Document with the given nodes.
    bool AddCmm(qif191::t::CCarriagesType& carriagesRoot, qif191::t::CMeasurementDevicesType& measurementDevicesRoot, qif191::t::CToolsType& toolsRoot, const qifbase::CmmParameters& cmmParameters, const std::vector<unsigned>& sensorIdList);

    // Writes the given List<double> as a string, with commas (and no spaces) in between.
    std::wstring FormatArrayDecimal(const std::vector<double>& testResults);

    // Loads the CMM list from the given QIF document. Private method that actually carries out the bulk of the work.
    bool DoLoad(qif191::t::CQIFDocument& document, std::vector<std::unique_ptr<qifbase::CmmParameters> >& cmmList);

    // Loads all the sensors, hashed by their ID
    bool LoadSensors(qif191::t::CQIFDocument& document, std::map<unsigned, qifbase::SensorParameters>& sensorMapping);

    // Loads the given sensor node into a SensorParameters object
    bool LoadSensor(qif191::t::CSensorType* sensor, qifbase::SensorParameters& sp);

    // Loads all CMMs, along with their associated sensor IDs.
    bool LoadCMMs(qif191::t::CQIFDocument& document, CmmMapping& cmmMapping);

    // Loads the given CMM and the sensor ids for it.
    bool LoadCMM(qif191::t::CCMMType* cmm, qif191::t::CCarriagesType* carriagesRoot, qif191::t::CToolsType* toolsRoot, std::unique_ptr<qifbase::CmmParameters>& cp, std::vector<unsigned>& sensorIdList);

    // Convert between a CmmType to a qif191::t::CCMMGeometryEnumTypeType
    qif191::t::CCMMGeometryEnumTypeType::EnumValues ConvertCmmType(qifbase::CmmType type);
    bool ConvertCmmType(qif191::t::CCMMGeometryEnumTypeType::EnumValues type, qifbase::CmmType& convertedValue);

    // Convert between axis orientations
    qif191::t::CCMMDirectionEnumTypeType::EnumValues ConvertAxisOrientation(qifbase::CmmAxisOrientation o);
    qifbase::CmmAxisOrientation ConvertAxisOrientation(qif191::t::CCMMDirectionEnumTypeType::EnumValues o);

    // Takes the string found in the Description element of either the CMM or Probe and breaks it down into a Dictionary of key value pairs
    void GetValuesInDescription(std::wstring descriptionElementContents, std::map<std::wstring, std::wstring>& table);

    // Returns a list of the performance test values under the given key. Returns an empty list if there is no such key, or the key is there, but value is empty.
    void GetPerformanceTestValues(std::wstring key, const std::map<std::wstring, std::wstring>& descriptionValues, std::vector<double>& values);

    // Appends the sensors found on the given carriage to the given List<double>
    void GetSensorsOfCarriage(qif191::t::CCarriagesType* carriagesRoot, qif191::t::CToolsType* toolsRoot, unsigned carriageId, std::vector<unsigned>& sensorIdList);

    // Appends the sensors found on the given tool to the given List<double>
    void GetSensorsOfTool(qif191::t::CToolsType* toolsRoot, unsigned toolId, std::vector<unsigned>& sensorIdList);

    // Primes the QIF Id generator for a new file
    void ResetQifIds();

    // Returns the next QIF id
    unsigned GetQifId();

    // Splits the given string according to the given delimiter
    void SplitString(const std::wstring& str, wchar_t delim, std::vector<std::wstring>& tokenList, bool skipEmptyTokens = true);

    // Gets an int value from the given description mapping with the given key. Returns false if it doesn't exist, or couldn't be parsed.
    bool GetIntValueFromDescription(const std::map<std::wstring, std::wstring>& descriptionValues, const std::wstring& key, int& value);

    // Gets a double value from the given description mapping with the given key. Returns false if it doesn't exist, or couldn't be parsed.
    bool GetDoubleValueFromDescription(const std::map<std::wstring, std::wstring>& descriptionValues, const std::wstring& key, double& value);

    // Adds an error to our list of errors
    void Error(std::wstring errorMessage, std::wstring errorMessageDetails = std::wstring(L""));

    // Adds an warning to our list of warnings
    void Warning(std::wstring warningMessage, std::wstring warningMessageDetails = std::wstring(L""));

private:
    // File path
    std::wstring _filename;
    // Errors
    std::vector<std::wstring> _errorList;
    // Error details
    std::vector<std::wstring> _errorDetailsList;
    // Warnings
    std::vector<std::wstring> _warningList;
    // Warning details
    std::vector<std::wstring> _warningDetailsList;
};
}

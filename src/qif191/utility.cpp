// Copyright(c) Capvidia, 2020
// https://www.capvidia.com
//
// Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software
// and accompanying documentation covered by this license(the "Software") to use, reproduce, display, distribute, execute,
// and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the Software
// is furnished to do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement,
// including the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and all derivative works of the Software,
// unless such copies or derivative works are solely in the form of machine-executable object code generated by a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT.
// IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#include "StdAfx.h"
#include "utility.h"
#include <sstream>

using namespace std;

namespace qif191
{
/// <summary> Gets coordinates associated with the given point. </summary>
/// <param name="pt"> Point </param>
/// <param name="x"> X coordinate </param>
/// <param name="y"> Y coordinate </param>
/// <param name="z"> Z coordinate </param>
void GetPointValues(qif191::t::CPointSimpleTypeType* pt, double& x, double& y, double& z)
{
    tstringstream ss(*pt);
    ss >> x >> y >> z;
}

/// <summary> Sets point coordinates. </summary>
/// <param name="pt"> Point </param>
/// <param name="x"> X coordinate </param>
/// <param name="y"> Y coordinate </param>
/// <param name="z"> Z coordinate </param>
void SetPointValues(qif191::t::CPointSimpleTypeType& pt, double x, double y, double z)
{
    tstringstream ss;
    ss << x << _T(" ") << y << _T(" ") << z;
    pt = ss.str();
}

/// <summary> Gets coordinates associated with the given unit vector. </summary>
/// <param name="vec"> Unit vector </param>
/// <param name="x"> X coordinate </param>
/// <param name="y"> Y coordinate </param>
/// <param name="z"> Z coordinate </param>
void GetUnitVectorValues(qif191::t::CUnitVectorSimpleTypeType* vec, double& x, double& y, double& z)
{
    tstringstream ss(*vec);
    ss >> x >> y >> z;
}

/// <summary> Sets the value of the given unit vector to the value of the given coordinates. </summary>
/// <param name="vec"> Unit vector </param>
/// <param name="x"> X coordinate </param>
/// <param name="y"> Y coordinate </param>
/// <param name="z"> Z coordinate </param>
void SetUnitVectorValues(qif191::t::CUnitVectorSimpleTypeType& vec, double x, double y, double z)
{
    tstringstream ss;
    ss << x << _T(" ") << y << _T(" ") << z;
    vec = ss.str();
}

/// <summary> Gets array of 3D points associated with the given polyline. </summary>
/// <param name="p"> Polyline </param>
/// <param name="pointList"> Array of points </param>
void GetPolyLineValues(qif191::t::CPolyLineType* p, vector<double>& pointList)
{
    // Clear and reserve space for the vector
#pragma warning(push)
#pragma warning(disable:4244)
    pointList.clear();
    pointList.reserve(p->N * 3);
#pragma warning(pop)

    // Grab the values
    double x, y, z;
    tstringstream ss(*p);
    for(size_t i = 0; i < p->N; i++)
    {
        ss >> x >> y >> z;
        pointList.push_back(x);
        pointList.push_back(y);
        pointList.push_back(z);
    }
}

/// <summary>
/// Takes in the given DOMNode and casts it to a CSensorType, if it is of one of the derived types.
/// The list of derived types is defined as the items between _altova_mi_t_altova_CSensorsType_altova_Sensor
/// and _altova_mil_t_altova_CSensorsType
/// </summary>
/// <param name="node"> Node to cast </param>
/// <returns> Sensor or null </returns>
unique_ptr<qif191::t::CSensorType> CastToSensor(xercesc::DOMNode* node)
{
    if(XercesTreeOperations::IsMember(node, qif191::members + qif191::_altova_mi_t_altova_CSensorsType_altova_Sensor))
        return unique_ptr<qif191::t::CSensorType>(new qif191::t::CSensorType((qif191::t::CSensorType)node));
    if(XercesTreeOperations::IsMember(node, qif191::members + qif191::_altova_mi_t_altova_CSensorsType_altova_TouchProbe))
        return unique_ptr<qif191::t::CSensorType>(new qif191::t::CTouchProbeType((qif191::t::CTouchProbeType)node));
    return nullptr;
}
}

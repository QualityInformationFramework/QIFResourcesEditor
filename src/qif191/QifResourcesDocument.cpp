// Copyright(c) Capvidia, 2020
// https://www.capvidia.com
//
// Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software
// and accompanying documentation covered by this license(the "Software") to use, reproduce, display, distribute, execute,
// and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the Software
// is furnished to do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement,
// including the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and all derivative works of the Software,
// unless such copies or derivative works are solely in the form of machine-executable object code generated by a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT.
// IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#include "Stdafx.h"
#include "QifResourcesDocument.h"
#include "utility.h"
#include <qifbase/AltovaXML/XmlException.h>
#include <xercesc/parsers/XercesDOMParser.hpp>
#include <xercesc/framework/MemBufInputSource.hpp>
#include <xercesc/framework/Wrapper4InputSource.hpp>
#include <xercesc/framework/MemBufFormatTarget.hpp>
#include <xercesc/sax2/DefaultHandler.hpp>
#include <xercesc/util/PlatformUtils.hpp>
#include <xercesc/dom/DOMNamedNodeMap.hpp>
#include <xercesc/dom/DOMElement.hpp>
#include <xercesc/dom/DOMException.hpp>
#include <xercesc/dom/DOMLSSerializer.hpp>
#include <xercesc/dom/DOMLSOutput.hpp>
#include <xercesc/dom/DOMImplementation.hpp>
#include <xercesc/dom/DOMProcessingInstruction.hpp>
#include <xercesc/dom/DOMAttr.hpp>
#include <xercesc/dom/DOMText.hpp>
#include <sstream>
//#include <cpprest/filestream.h>

using namespace std;
using namespace qifbase;

// The version of QIF that we are saving as 
#define QIF_SAVE_VERSION L"1.9.1"

// Turn this switch on to output the CMM/probe data after loading/saving.
//#define TRACE_RESOURCE_IO

namespace qif191
{
/// <summary> Wraps map from CMM to sensors and keeps order of CMM adding. </summary>
class CmmMapping
{
    typedef map<unique_ptr<qifbase::CmmParameters>, vector<unsigned>> mapCmmSensors;

public:
    void Clear();
    void AddCmm(unique_ptr<qifbase::CmmParameters>&& cmm, vector<unsigned>&& sensorIds);
    const vector<mapCmmSensors::iterator>& Cmms() const { return _order; }

private:
    // Map elements in order of adding
    vector<mapCmmSensors::iterator> _order;
    // Map from CMM to sensors
    mapCmmSensors _mapCmmSensor;
};

/// <summary> Clears the mapping. </summary>
inline void CmmMapping::Clear()
{
    _order.clear();
    _mapCmmSensor.clear();
}

/// <summary> Adds a CMM and its list of sensor to the mapping. </summary>
/// <param name="cmm"> CMM </param>
/// <param name="sensorIds"> List of sensor identifiers </param>
void CmmMapping::AddCmm(unique_ptr<qifbase::CmmParameters>&& cmm, vector<unsigned>&& sensorIds)
{
    auto it = _mapCmmSensor.insert(pair<unique_ptr<qifbase::CmmParameters>, vector<unsigned>>(std::move(cmm), sensorIds));
    _order.push_back(it.first);
}

/// <summary> Constructs a QIF Document that will use the given path </summary>
/// <param name="path"> File path </param>
QifResourcesDocument::QifResourcesDocument(std::wstring path)
{
    _filename = path;
}

/// <summary> Saves the given CMM list to the QIF document. . </summary>
/// <param name="cmmParameters"> CMMs to save </param>
/// <returns> True in case of success, otherwise false </returns>
bool QifResourcesDocument::Save(const vector<unique_ptr<CmmParameters> >& cmmParameters)
{
    if(cmmParameters.empty())
    {
        Error(L"List of measurement resources is empty.");
        return false;
    }

    // Reset the ID list for the QIF Ids
    ResetQifIds();

    // Initialize xerces
    xercesc::XMLPlatformUtils::Initialize();

    // Create the QIF Document
    qif191::t::CQIFDocument xmlDocument = qif191::t::CQIFDocument::CreateDocument();

    // Build the QIF Document
    try
    {
        if(DoSave(xmlDocument, cmmParameters) == false)
            return false;
    }
    catch(exception ex)
    {
        string tmp(ex.what());
        wstring errorMessageDetails;
        errorMessageDetails.assign(tmp.begin(), tmp.end());
        errorMessageDetails = _T("Exception: ") + errorMessageDetails + _T("\n");
        Error(L"Error while creating QIF XML document", errorMessageDetails);
        return false;
    }

    // Write the file
    wstring errorMessage = _T("Error loading file ") + wstring(_filename);
    std::wstring fileStreamError;
    try
    {
        // Save out the XML doc to a file
        xmlDocument.SetSchemaLocation(L"\\QIFApplications\\QIFDocument.xsd"); // optional
        xmlDocument.SaveToFile(_filename, true); // "true" is for pretty printing of file

        // Destroy the XML document now that we are done with it.
        xmlDocument.DestroyDocument();
    }
    catch(altova::CXmlException& e)
    {
        fileStreamError = _T("Error: ") + (e.GetInfo()) + _T("\n");
        Error(errorMessage, fileStreamError);
        return false;
    }
    catch(xercesc::XMLException& e)
    {
        std::wstring wtmp;
        std::string tmp(e.getSrcFile());
        wtmp.assign(tmp.begin(), tmp.end());
        fileStreamError = _T("Xerces XMLException: ") + wtmp + _T("(") + std::to_wstring(e.getSrcLine()) + _T("): ") + e.getMessage() + _T("\n");
        Error(errorMessage, fileStreamError);
        return false;
    }
    catch(xercesc::DOMException& e)
    {
        fileStreamError = _T("Xerces DOMException ") + std::to_wstring(e.code);
        if(e.msg)
            fileStreamError = _T(": ") + std::wstring(e.msg);
        fileStreamError += _T("\n");
        Error(errorMessage, fileStreamError);
        return false;
    }
    catch(altova::Exception& exception)
    {
        fileStreamError = _T("Exception: ") + exception.message() + _T("\n");
        Error(errorMessage, fileStreamError);
        return false;
    }
    catch(altova::Error& exception)
    {
        fileStreamError = _T("Error: ") + exception.message() + _T("\n");
        Error(errorMessage, fileStreamError);
        return false;
    }
    catch(std::exception& e)
    {
        std::string tmp(e.what());
        fileStreamError.assign(tmp.begin(), tmp.end());
        fileStreamError = _T("Exception: ") + fileStreamError + _T("\n");
        Error(errorMessage, fileStreamError);
        return false;
    }
    catch(...)
    {
        fileStreamError = _T("Unknown error\n");
        Error(errorMessage, fileStreamError);
        return false;
    }

    return true;
}

/// <summary> Loads a list of CMMs from the QIF document. </summary>
/// <param name="cmmList"> Loaded CMMs </param>
/// <returns> True in case of success, otherwise false </returns>
bool QifResourcesDocument::Load(vector<unique_ptr<CmmParameters>>& cmmList)
{
    cmmList.clear();

    // Try to load the file
    wstring errorMessage = _T("Error loading file ") + wstring(_filename);
    std::wstring fileStreamError;
    try
    {
        // Open the file
        xercesc::XMLPlatformUtils::Initialize();
        qif191::t::CQIFDocument xmlDocument = qif191::t::CQIFDocument::LoadFromFile(_filename);

        // Look at the version, and make sure we can open it.
        bool versionSupported = false;
        if(xmlDocument.QIFDocument2.exists() && xmlDocument.QIFDocument2.first().versionQIF.exists())
        {
            const vector<wstring> versions = {L"1.9.1", L"1.9.2", L"1.9.3", L"1.9.4", L"2.0.0"};
            wstring version = xmlDocument.QIFDocument2.first().versionQIF;
            for(auto&& v : versions)
            {
                if(v == version)
                {
                    versionSupported = true;
                    break;
                }
            }
        }
        if(versionSupported == false)
        {
            Error(errorMessage, L"File type not supported");
            return false;
        }

        // Load the data from it.
        if(DoLoad(xmlDocument, cmmList) == false)
            return false;

        // Destroy the XML document now that we are done with it.
        xmlDocument.DestroyDocument();
    }
    catch(altova::CXmlException& e)
    {
        fileStreamError = _T("Error: ") + (e.GetInfo()) + _T("\n");
        Error(errorMessage, fileStreamError);
        return false;
    }
    catch(xercesc::XMLException& e)
    {
        std::wstring wtmp;
        std::string tmp(e.getSrcFile());
        wtmp.assign(tmp.begin(), tmp.end());
        fileStreamError = _T("Xerces XMLException: ") + wtmp + _T("(") + std::to_wstring(e.getSrcLine()) + _T("): ") + e.getMessage() + _T("\n");
        Error(errorMessage, fileStreamError);
        return false;
    }
    catch(xercesc::DOMException& e)
    {
        fileStreamError = _T("Xerces DOMException ") + std::to_wstring(e.code);
        if(e.msg)
            fileStreamError = _T(": ") + std::wstring(e.msg);
        fileStreamError += _T("\n");
        Error(errorMessage, fileStreamError);
        return false;
    }
    catch(altova::Exception& exception)
    {
        fileStreamError = _T("Exception: ") + exception.message() + _T("\n");
        Error(errorMessage, fileStreamError);
        return false;
    }
    catch(altova::Error& exception)
    {
        fileStreamError = _T("Error: ") + exception.message() + _T("\n");
        Error(errorMessage, fileStreamError);
        return false;
    }
    catch(std::exception& e)
    {
        std::string tmp(e.what());
        fileStreamError.assign(tmp.begin(), tmp.end());
        fileStreamError = _T("Exception: ") + fileStreamError + _T("\n");
        Error(errorMessage, fileStreamError);
        return false;
    }
    catch(...)
    {
        fileStreamError = _T("Unknown error\n");
        Error(errorMessage, fileStreamError);
        return false;
    }

    // Done
    return true;
}

/// <summary> Finds the specified sensor in the given sensor list. </summary>
/// <param name="savedSensorList"> Sensor list </param>
/// <param name="item"> Sensor to find </param>
/// <returns> Sensor to sensor or null if it was not found </returns>
static SensorParameters* FindSensor(vector<SensorParameters*>& savedSensorList, SensorParameters* item)
{
    for(auto it = savedSensorList.begin(); it != savedSensorList.end(); it++)
    {
        if(**it == *item)
            return *it;
    }
    return nullptr;
}

/// <summary> Saves the given CMM list to the QIF document. Private method that actually carries out the bulk of the work. </summary>
/// <param name="document"> Document </param>
/// <param name="cmmParameters"> CMMs to save </param>
/// <returns> True in case of success, otherwise false </returns>
bool QifResourcesDocument::DoSave(qif191::t::CQIFDocument& document, const vector<unique_ptr<CmmParameters>>& cmmParameters)
{
    // Create the file and the root MeasurementResources node
    qif191::t::CQIFDocumentType docRoot = document.QIFDocument2.append();
    docRoot.versionQIF = QIF_SAVE_VERSION;
    qif191::t::CMeasurementResourcesType measurementResourcesRoot = docRoot.MeasurementResources.append();

    // List of Measurement Devices (of which CMM is a type), list of carriages, list of sensors
    qif191::t::CCarriagesType carriagesRoot = measurementResourcesRoot.Carriages.append();
    qif191::t::CMeasurementDevicesType measurementDevicesRoot = measurementResourcesRoot.MeasurementDevices.append();
    qif191::t::CSensorsType sensorsRoot = measurementResourcesRoot.Sensors.append();
    qif191::t::CToolsType toolsRoot = measurementResourcesRoot.Tools.append();

    // Keep track of the sensors that have been added to the file. We will reuse the sensors that are identical. We will keep
    // 2 vectors: one for the saved sensors, and one for the IDs of these sensors. These 2 vectors will be kept in sync
    vector<SensorParameters*> savedSensorList;
    vector<unsigned> savedSensorIdList;

    // Loop through each CMM
    for(vector<unique_ptr<CmmParameters> >::const_iterator cmmIterator = cmmParameters.begin(); cmmIterator != cmmParameters.end(); cmmIterator++)
    {
        CmmParameters* cmm = (*cmmIterator).get();

        // Add all the probes to the QIF doc, and keep track of the IDs
        vector<unsigned> sensorIdList;
        for(vector<SensorParameters*>::const_iterator sensorIterator = cmm->Sensors().begin(); sensorIterator != cmm->Sensors().end(); sensorIterator++)
        {
            unsigned sensorId;

            // See if this sensor has already been added to the document. If so, then re-use that sensor ID. 
            vector<SensorParameters*>::const_iterator savedSensorListIt = savedSensorList.begin();
            for(; savedSensorListIt != savedSensorList.end(); savedSensorListIt++)
                if(**savedSensorListIt == **sensorIterator)
                    break;
            //vector<SensorParameters>::const_iterator savedSensorListIt = std::find(savedSensorList.begin(), savedSensorList.end(), *sensorIterator);
            if(savedSensorListIt != savedSensorList.end())
            {
                size_t savedSensorIndex = savedSensorListIt - savedSensorList.begin();
                sensorId = savedSensorIdList[savedSensorIndex];
            }
            else
            {
                // Otherwise, add the sensor to the document.
                AddProbe(sensorsRoot, **sensorIterator, sensorId);
                savedSensorList.push_back(*sensorIterator);
                savedSensorIdList.push_back(sensorId);
            }

            // Save the ID for this sensor.
            sensorIdList.push_back(sensorId);
        }

        // Create this CMM
        if(AddCmm(carriagesRoot, measurementDevicesRoot, toolsRoot, *cmm, sensorIdList) == false)
            return false;
    }

    return true;
}

/// <summary> Adds a probe to the given sensor root of a QIF document.  </summary>
/// <param name="sensorsRoot"> QIF sensor root </param>
/// <param name="probeParameters"> Probe to add </param>
/// <param name="newSensorId"> ID of added probe </param>
void QifResourcesDocument::AddProbe(qif191::t::CSensorsType& sensorsRoot, const SensorParameters& probeParameters, unsigned& newSensorId)
{
    // Attach a new probe to the probe root node
    qif191::t::CTouchProbeType probe = sensorsRoot.TouchProbe.append();

    // Attach ID, name, A & B angle data. For QIF 2.0, all the other data needs to go in the "Description" element.
    probe.id = GetQifId();
    probe.Name.append() = probeParameters.Name();
    probe.Description.append();
    probe.Qualifications.append().Qualification.append().Description.append() = L"";
    probe.AAngle.append() = probeParameters.AAngle();
    probe.BAngle.append() = probeParameters.BAngle();
    probe.TipDiameter.append() = 0;
    std::wstring probeDesc(L"");

    // SensorType, to be put in the Description element
    probeDesc += L"SensorType=" + to_wstring(probeParameters.Type()) + L";";

    // SensorTechnology, to be put in the Description element
    probeDesc += L"SensorTechnology=" + to_wstring(probeParameters.Technology()) + L";";

    // Performance test data, to be put in the Description element
    probeDesc += L"ActivePerformanceTest=" + to_wstring(probeParameters.ActivePerformanceTest()) + L";";
    if(probeParameters.PerformanceTestIso10360().size() > 0)
        probeDesc += L"PerformanceTestIso10360=" + FormatArrayDecimal(probeParameters.PerformanceTestIso10360()) + L";";
    if(probeParameters.PerformanceTestB89().size() > 0)
        probeDesc += L"PerformanceTestB89=" + FormatArrayDecimal(probeParameters.PerformanceTestB89()) + L";";
    if(probeParameters.PerformanceTestVdiVde().size() > 0)
        probeDesc += L"PerformanceTestVdiVde=" + FormatArrayDecimal(probeParameters.PerformanceTestVdiVde()) + L";";
    if(probeParameters.PerformanceTestSpecifiedStandardDeviation().size() > 0)
        probeDesc += L"PerformanceTestSpecifiedStandardDeviation=" + FormatArrayDecimal(probeParameters.PerformanceTestSpecifiedStandardDeviation()) + L";";

    // The B angle adjustment.  Only used for the articulating head model. 
    if(probeParameters.Type() == SensorType::SingleTipArticulated)
        probeDesc += L"BAngleAdjustment=" + to_wstring(probeParameters.BAngleAdjustment()) + L";";

    // Stylus length(s), to be put in the Description element
    for(size_t i = 0; i < probeParameters.StylusLengths().size(); i++)
    {
        probeDesc += L"StylusLength" + to_wstring(i + 1) + L"=";
        probeDesc += to_wstring(probeParameters.StylusLengths()[i]) + L";";
    }

    // Probe extension length, to be put in the Description element (optional element)
    if(probeParameters.ExtensionLength() > 0)
        probeDesc += L"Extension=" + to_wstring(probeParameters.ExtensionLength()) + L";";

    // Add the description to the probe and return the ID of this newly created probe.
    probe.Description.first() = probeDesc;
#ifdef TRACE_RESOURCE_IO
    TRACE(probeDesc);
#endif
    newSensorId = probe.id;
}

/// <summary> Adds the given CMM Parameters with the attached sensors to the QIF Document with the given nodes. </summary>
/// <param name="carriagesRoot"> Carriage root </param>
/// <param name="measurementDevicesRoot"> Measurement devices root </param>
/// <param name="toolsRoot"> Tools root </param>
/// <param name="cmmParameters"> CMM to add </param>
/// <param name="sensorIdList"> Sensors of the CMM </param>
/// <returns> True in case of success, otherwise false </returns>
bool QifResourcesDocument::AddCmm(qif191::t::CCarriagesType& carriagesRoot,
                                  qif191::t::CMeasurementDevicesType& measurementDevicesRoot,
                                  qif191::t::CToolsType& toolsRoot,
                                  const CmmParameters& cmmParameters,
                                  const vector<unsigned>& sensorIdList)
{
    // Create the CMM node
    qif191::t::CCMMType cmm = measurementDevicesRoot.CMM.append();

    // Create Name and ID, and initialize the Description
    cmm.Name.append() = cmmParameters.Name();
    cmm.id = GetQifId();
    cmm.Description.append();
    std::wstring cmmDescription(L"");

    // Create the Tools node for this CMM. This Tools node contains all the IDs of the sensors for this CMM.
    qif191::t::CToolType cmmTools = toolsRoot.Tool.append();
    cmmTools.id = GetQifId();
    cmmTools.Name.append() = std::wstring(cmm.Name.first()) + L" available sensors";
    qif191::t::CArrayReferenceFullType cmmToolsSensorIds = cmmTools.SensorIds.append();
#pragma warning(push)
#pragma warning(disable : 4267)
    cmmToolsSensorIds.N = sensorIdList.size();
#pragma warning(pop)
    for(auto it = sensorIdList.begin(); it != sensorIdList.end(); it++)
        cmmToolsSensorIds.Id.append() = *it;

    // Carriage for the CMM. This carriage points to the ID of the Tools node we created above.
    qif191::t::CCarriageType cmmCarriage = carriagesRoot.Carriage.append();
    cmmCarriage.id = GetQifId();
    cmmCarriage.Name.append() = std::wstring(cmm.Name.first()) + L" carriage";
    cmmCarriage.ToolIds.append().N = 1;
    cmmCarriage.ToolIds.first().Id.append() = cmmTools.id;

    // CMM temperature. Specify upper and lower limit. Also, put laser CMM scales info and software compensation type in the "Description"
    double temp = 19.5;
    double tempUnc = 1.5;
    qif191::t::CTemperaturesType cmmTemps = cmm.InspectionTemperatures.append();
    qif191::t::CTemperatureType cmmLowerTemp = cmmTemps.Temperature.append();
    cmmLowerTemp.Temperature.append() = cmmParameters.CmmTemperature() - cmmParameters.CmmTemperatureUncertainty();
    cmmLowerTemp.TimeStamp.append() = altova::DateTime();
    qif191::t::CTemperatureType cmmUpperTemp = cmmTemps.Temperature.append();
    cmmUpperTemp.Temperature.append() = cmmParameters.CmmTemperature() + cmmParameters.CmmTemperatureUncertainty();
    cmmUpperTemp.TimeStamp.append() = altova::DateTime();
    cmmDescription += L"CmmLaserAirTemperature=" + to_wstring(cmmParameters.CmmLaserAirTemperature()) + L";";
    cmmDescription += L"CmmLaserAirTemperatureUncertainty=" + to_wstring(cmmParameters.CmmLaserAirTemperatureUncertainty()) + L";";
    cmmDescription += L"CmmLaserAirPressure=" + to_wstring(cmmParameters.CmmLaserAirPressure()) + L";";
    cmmDescription += L"CmmLaserAirPressureUncertainty=" + to_wstring(cmmParameters.CmmLaserAirPressureUncertainty()) + L";";
    cmmDescription += L"CmmLaserAirHumidity=" + to_wstring(cmmParameters.CmmLaserAirHumidity()) + L";";
    cmmDescription += L"CmmLaserAirHumidityUncertainty=" + to_wstring(cmmParameters.CmmLaserAirHumidityUncertainty()) + L";";
    cmmDescription += L"CmmSoftwareCompensation=" + to_wstring(cmmParameters.CmmSoftwareCompensation()) + L";";

    // Working volume 
    qif191::t::CWorkingVolumeType cmmWorkingVolume = cmm.WorkingVolume.append();
    cmmWorkingVolume.XAxisLength.append() = cmmParameters.Extents()[0];
    cmmWorkingVolume.YAxisLength.append() = cmmParameters.Extents()[1];
    cmmWorkingVolume.ZAxisLength.append() = cmmParameters.Extents()[2];
    cmmDescription += L"Zero0=" + to_wstring(cmmParameters.Zero()[0]) + L";";
    cmmDescription += L"Zero1=" + to_wstring(cmmParameters.Zero()[1]) + L";";
    cmmDescription += L"Zero2=" + to_wstring(cmmParameters.Zero()[2]) + L";";

    // CMM geometry type
    qif191::t::CCMMGeometryEnumTypeType::EnumValues cmmType = ConvertCmmType(cmmParameters.Type());
    if(cmmType != qif191::t::CCMMGeometryEnumTypeType::Invalid)
        cmm.MachineGeometry.append().CMMGeometryEnum.append().SetEnumerationValue(cmmType);
    else
        cmm.MachineGeometry.append().OtherCMMGeometry.append() = to_wstring(cmmParameters.Type());

    // Axis directions
    qif191::t::CCMMAxisDirectionsType cmmAxisDirections = cmm.AxisOrientation.append();
    cmmAxisDirections.XAxisDirection.append().SetEnumerationValue(ConvertAxisOrientation(cmmParameters.AxisOrientationX()));
    cmmAxisDirections.YAxisDirection.append().SetEnumerationValue(ConvertAxisOrientation(cmmParameters.AxisOrientationY()));
    cmmAxisDirections.ZAxisDirection.append().SetEnumerationValue(ConvertAxisOrientation(cmmParameters.AxisOrientationZ()));

    // CMM Scales
    qif191::t::CCMMScalesType cmmScales = cmm.CMMScales.append();
    qif191::t::CCMMScaleType cmmXScale = cmmScales.XScale.append();
    cmmXScale.ScaleMaterial.append() = L"";
    cmmXScale.ScaleCoefficientOfExpansion.append() = cmmParameters.CmmExpansionCoefficient();
    cmmXScale.ScaleCoefficientOfExpansionUncertainty.append() = cmmParameters.CmmExpansionCoefficientUncertainty();
    cmmXScale.TypeOfScale.append() = to_wstring(cmmParameters.CmmScales());
    cmmXScale.ScaleResolution.append() = 0;
    qif191::t::CCMMScaleType cmmYScale = cmmScales.YScale.append();
    cmmYScale.ScaleMaterial.append() = L"";
    cmmYScale.ScaleCoefficientOfExpansion.append() = cmmParameters.CmmExpansionCoefficient();
    cmmYScale.ScaleCoefficientOfExpansionUncertainty.append() = cmmParameters.CmmExpansionCoefficientUncertainty();
    cmmYScale.TypeOfScale.append() = to_wstring(cmmParameters.CmmScales());
    cmmYScale.ScaleResolution.append() = 0;
    qif191::t::CCMMScaleType cmmZScale = cmmScales.ZScale.append();
    cmmZScale.ScaleMaterial.append() = L"";
    cmmZScale.ScaleCoefficientOfExpansion.append() = cmmParameters.CmmExpansionCoefficient();
    cmmZScale.ScaleCoefficientOfExpansionUncertainty.append() = cmmParameters.CmmExpansionCoefficientUncertainty();
    cmmZScale.TypeOfScale.append() = to_wstring(cmmParameters.CmmScales());
    cmmZScale.ScaleResolution.append() = 0;

    // Performance test, ISO 10360
    if(cmmParameters.ActivePerformanceTest() == CmmPerformanceTest::Iso10360Cmm)
    {
        if(cmmParameters.Iso10360Results() == nullptr)
        {
            Error(L"Error saving CMM " + cmmParameters.Name(), L"ISO 10360 CMM performance test was selected as the active test, but there are no values");
            return false;
        }
        qif191::t::CCMMAccuracyType cmmActualAccuracy = cmm.ActualAccuracy.append();
        cmmActualAccuracy.MinTemperature.append() = 20;
        cmmActualAccuracy.MaxTemperature.append() = 20;
        qif191::t::CISO10360TestType cmm2iso10360 = cmmActualAccuracy.ISO10360Test.append();
        if(cmmParameters.Iso10360Results()->ErrorOfIndicationType() == CmmErrorIso10360::ErrorType::OneValue)
        {
            cmm2iso10360.MaxErrorConstant.append() = cmmParameters.Iso10360Results()->ErrorOfIndicationValue3();
        }
        else if(cmmParameters.Iso10360Results()->ErrorOfIndicationType() == CmmErrorIso10360::ErrorType::TwoValues)
        {
            cmm2iso10360.LinearError.append().BaseError.append() = cmmParameters.Iso10360Results()->ErrorOfIndicationValue1();
            cmm2iso10360.LinearError.first().ErrorRate.append() = cmmParameters.Iso10360Results()->ErrorOfIndicationValue2();
        }
        else if(cmmParameters.Iso10360Results()->ErrorOfIndicationType() == CmmErrorIso10360::ErrorType::ThreeValues)
        {
            qif191::t::CLesserErrorType lesserError = cmm2iso10360.LesserError.append();
            lesserError.MaxErrorConstant.append() = cmmParameters.Iso10360Results()->ErrorOfIndicationValue3();
            lesserError.LinearError.append().BaseError.append() = cmmParameters.Iso10360Results()->ErrorOfIndicationValue1();
            lesserError.LinearError.first().ErrorRate.append() = cmmParameters.Iso10360Results()->ErrorOfIndicationValue2();
        }
        else
        {
            Error(L"Error saving CMM " + cmmParameters.Name(), L"Error saving ISO 10360 mpe values");
            return false;
        }

        // Artifact type
        cmmDescription += L"IsoArtifact=" + to_wstring(cmmParameters.Iso10360Results()->Artifact()) + L";";

        // Artifact positions
        for(int i = 0; i < cmmParameters.Iso10360Results()->ArtifactPositionCount(); i++)
            cmmDescription += L"IsoArtifactPosition" + to_wstring(i + 1) + L"=" + to_wstring(cmmParameters.Iso10360Results()->ArtifactPositionValue(i)) + L";";

        // Stacking order (gage blocks only)
        if(cmmParameters.Iso10360Results()->Artifact() == CmmErrorIso10360::ArtifactType::GageBlocks)
            for(int i = 0; i < cmmParameters.Iso10360Results()->ArtifactPositionCount(); i++)
                cmmDescription += L"IsoArtifactStackingOrder" + to_wstring(i + 1) + L"=" + to_wstring(cmmParameters.Iso10360Results()->GageBlockStackingValue(i)) + L";";
    }
    // Performance Test, B89
    else if(cmmParameters.ActivePerformanceTest() == CmmPerformanceTest::B89)
    {
        if(cmmParameters.B89Results() == nullptr)
        {
            Error(L"Error saving CMM " + cmmParameters.Name(), L"B89 CMM performance test was selected as the active test, but there are no values");
            return false;
        }
        qif191::t::CCMMAccuracyType cmmActualAccuracy = cmm.ActualAccuracy.append();
        cmmActualAccuracy.MinTemperature.append() = 20;
        cmmActualAccuracy.MaxTemperature.append() = 20;
        qif191::t::CB89TestType cmmB89 = cmmActualAccuracy.B89Test.append();
        cmmB89.XLinearAccuracy.append() = cmmParameters.B89Results()->XLinearAccuracy();
        cmmB89.YLinearAccuracy.append() = cmmParameters.B89Results()->YLinearAccuracy();
        cmmB89.ZLinearAccuracy.append() = cmmParameters.B89Results()->ZLinearAccuracy();
        cmmB89.OffsetVolumetricPerformance.append() = cmmParameters.B89Results()->OffsetVolumetricPerformance();
        cmmB89.VolumetricPerformance.append() = cmmParameters.B89Results()->VolumetricPerformance();
        cmmB89.Repeatability.append() = cmmParameters.B89Results()->Repeatability();
    }
    // FPS CMM data
    else if(cmmParameters.ActivePerformanceTest() == CmmPerformanceTest::Parametric)
    {
        // TODO: FPS
    }

    // Rotary Table
    if(cmmParameters.HasRotaryTable())
    {
        // Rotary table location and size
        qif191::t::CRotaryTableType rotaryTable = cmm.RotaryTable.append();
        qif191::t::CPointType loc = rotaryTable.LocationOnCMM.append();
        qif191::t::CUnitVectorType dir = rotaryTable.AxisDirection.append();
        qif191::t::CUnitVectorType zerodir = rotaryTable.ZeroIndexDirection.append();
        qif191::SetPointValues(loc, cmmParameters.RotaryTableXOrigin(), cmmParameters.RotaryTableYOrigin(), cmmParameters.RotaryTableZOrigin());
        qif191::SetUnitVectorValues(dir, cmmParameters.RotaryTableAxisDirection()[0], cmmParameters.RotaryTableAxisDirection()[1], cmmParameters.RotaryTableAxisDirection()[2]);
        qif191::SetUnitVectorValues(zerodir, cmmParameters.RotaryTableZeroIndexDirection()[0], cmmParameters.RotaryTableZeroIndexDirection()[1], cmmParameters.RotaryTableZeroIndexDirection()[2]);
        rotaryTable.TableRadius.append() = cmmParameters.RotaryTableRadius();

        // Rotary table errors
        qif191::t::CTableErrorsType rotaryTableErrors = rotaryTable.TableErrors.append();
        rotaryTableErrors.AxialError.append() = cmmParameters.RotaryTableAxialError();
        rotaryTableErrors.RadialError.append() = cmmParameters.RotaryTableRadialError();
        rotaryTableErrors.TangentialError.append() = cmmParameters.RotaryTableTangentialError();
    }

    // Carriage
    cmm.CarriageIds.append().N = 1;
    cmm.CarriageIds.first().Id.append() = cmmCarriage.id;

    // Finally, write the cmm2 description
    cmm.Description.first() = cmmDescription;
#ifdef TRACE_RESOURCE_IO
    TRACE(cmmDescription);
#endif
    return (HadError() == false);
}

/// <summary> Writes the given list of numbers as a string, with commas (and no spaces) in between. </summary>
/// <param name="numbers"> list of decimal numbers </param>
/// <returns> String </returns>
wstring QifResourcesDocument::FormatArrayDecimal(const vector<double>& numbers)
{
    wstring s = L"";
    if(!numbers.empty())
    {
        s += to_wstring(numbers[0]);
        for(size_t i = 1; i < numbers.size(); i++)
            s += L"," + to_wstring(numbers[i]);
    }
    return s;
}

/// <summary> Loads the CMM list from the given QIF document. Private method that actually carries out the bulk of the work. </summary>
/// <param name="document"> XML QIF document </param>
/// <param name="cmmList"> Loaded CMMs </param>
/// <returns> True in case of success, otherwise false </returns>
bool QifResourcesDocument::DoLoad(qif191::t::CQIFDocument& document, vector<unique_ptr<CmmParameters> >& cmmList)
{
    cmmList.clear();

    // First, load all the sensors
    map<unsigned, SensorParameters> sensorMapping;
    LoadSensors(document, sensorMapping);

    // Now load all the CMMs
    CmmMapping loadedCmms;
    LoadCMMs(document, loadedCmms);

    // If there were any errors loading these items, exit now
    if(HadError())
        return false;

    // Build up our master list of CMM Parameters
    for(auto cmmMapIterator : loadedCmms.Cmms())
    {
        // Create a list of all SensorParameters for this CMM
        const vector<unsigned>& sensorIdList = cmmMapIterator->second;
        vector<SensorParameters*> sensorList;
        for(auto sensorIdListIterator = sensorIdList.begin(); sensorIdListIterator != sensorIdList.end(); sensorIdListIterator++)
        {
            // For each id in the list of Sensor ids, get the associated SensorParameter
            const auto sensorMapIterator = sensorMapping.find(*sensorIdListIterator);
            if(sensorMapIterator != sensorMapping.end())
            {
                // Add this SensorParameter if it was found
                sensorList.push_back(new SensorParameters(sensorMapIterator->second));
            }
        }

        // Create the CMM, add the list of sensors, and add the CMM to the list.
        unique_ptr<CmmParameters> cmm(new CmmParameters(*(cmmMapIterator->first)));
        cmm->Sensors(sensorList);
        cmmList.push_back(std::move(cmm));
    }

    return !HadError();
}

/// <summary> Loads all the sensors, hashed by their ID. </summary>
/// <param name="document"> XML QIF document </param>
/// <param name="sensorMapping"> Mapping: sensor identifier -> sensor </param>
/// <returns> True in case of success, otherwise false </returns>
bool QifResourcesDocument::LoadSensors(qif191::t::CQIFDocument& document, map<unsigned, SensorParameters>& sensorMapping)
{
    sensorMapping.clear();

    // Get the Sensors node of the document
    if(!document.QIFDocument2.exists())
    {
        Error(_filename + L" is an invalid QIF document");
        return false;
    }
    if(!document.QIFDocument2.first().MeasurementResources.exists())
    {
        Error(_filename + L" is an invalid QIF Resources document");
        return false;
    }
    if(!document.QIFDocument2.first().MeasurementResources.first().Sensors.exists())
    {
        Error(L"The QIF Resources document " + _filename + L" has no Sensors defined");
        return false;
    }
    qif191::t::CSensorsType sensorsRoot = document.QIFDocument2.first().MeasurementResources.first().Sensors.first();

    // Loop through all the sensors
    XercesTreeOperations::AllIterator allIterator = XercesTreeOperations::GetElements(sensorsRoot.GetNode());
    for(; allIterator; ++allIterator)
    {
        std::unique_ptr<qif191::t::CSensorType> sensor = qif191::CastToSensor(*allIterator);
        if(sensor != nullptr)
        {
            // Load this sensor
            SensorParameters sp;
            if(LoadSensor(sensor.get(), sp))
                sensorMapping[sensor->id] = sp;
        }
    }

    return !HadError();
}

/// <summary> Loads the given sensor node into a SensorParameters object. </summary>
/// <param name="sensor"> XML QIF sensor to load </param>
/// <param name="sp"> Loaded sensor </param>
/// <returns> True in case of success, otherwise false </returns>
bool QifResourcesDocument::LoadSensor(qif191::t::CSensorType* sensor, SensorParameters& sp)
{
    int intValue;
    double doubleValue;

    // Name. If there isn't one, we will put it as "Unnamed sensor"
    sp.Name(sensor->Name.exists() ? (wstring)sensor->Name.first() : L"");
    if(sp.Name() == L"")
        sp.Name(L"Unnamed sensor");

    // A and B angle
    if(sensor->AAngle.exists())
        sp.AAngle(sensor->AAngle.first());
    else
        Error(L"Error loading sensor " + sp.Name(), L"AAngle has no value");

    if(sensor->BAngle.exists())
        sp.BAngle(sensor->BAngle.first());
    else
        Error(L"Error loading sensor " + sp.Name(), L"BAngle has no value");

    // Get all the values in the description
    map<wstring, wstring> descriptionValues;
    GetValuesInDescription(sensor->Description.first(), descriptionValues);

    // Sensor Type
    if(GetIntValueFromDescription(descriptionValues, L"SensorType", intValue) == true)
        sp.Type((SensorType)intValue);
    else
        Error(L"Error loading sensor " + sp.Name(), L"SensorType has no value");

    // Sensor Technology
    if(GetIntValueFromDescription(descriptionValues, L"SensorTechnology", intValue) == true)
        sp.Technology((SensorTechnology)intValue);
    else
        Error(L"Error loading sensor " + sp.Name(), L"SensorTechnology has no value");

    // Performance test data
    if(GetIntValueFromDescription(descriptionValues, L"ActivePerformanceTest", intValue) == true)
        sp.ActivePerformanceTest((SensorPerformanceTest)intValue);
    else
        Error(L"Error loading sensor " + sp.Name(), L"ActivePerformanceTest has no value");

    vector<double> performanceTestValues;
    GetPerformanceTestValues(L"PerformanceTestVdiVde", descriptionValues, performanceTestValues);
    if(performanceTestValues.size() == 2)
        sp.PerformanceTestVdiVde(performanceTestValues);

    GetPerformanceTestValues(L"PerformanceTestB89", descriptionValues, performanceTestValues);
    if(performanceTestValues.size() == 2)
        sp.PerformanceTestB89(performanceTestValues);

    GetPerformanceTestValues(L"PerformanceTestSpecifiedStandardDeviation", descriptionValues, performanceTestValues);
    if(performanceTestValues.size() == 2)
        sp.PerformanceTestSpecifiedStandardDeviation(performanceTestValues);

    GetPerformanceTestValues(L"PerformanceTestIso10360", descriptionValues, performanceTestValues);
    if((performanceTestValues.size() == 2  && sp.Type() == SensorType::SingleTipFixed) ||
       (performanceTestValues.size() == 12 && sp.Type() == SensorType::SingleTipArticulated) ||
       (performanceTestValues.size() == 21 && sp.Type() == SensorType::MultiTipFixed))
        sp.PerformanceTestIso10360(performanceTestValues);

    // The B angle adjustment. Only used for the articulating head model. 
    if(sp.Type() == SensorType::SingleTipArticulated)
    {
        if(GetDoubleValueFromDescription(descriptionValues, L"BAngleAdjustment", doubleValue) == true)
            sp.BAngleAdjustment(doubleValue);
        else Error(L"Error loading sensor " + sp.Name(), L"BAngleAdjustment has no value");
    }

    // Stylus length(s)
    int stylusCount = sp.Type() == SensorType::MultiTipFixed ? 5 : 1;
    vector<double> stylusLengthList;
    bool err = false;
    for(int i = 0; i < stylusCount; i++)
    {
        if(GetDoubleValueFromDescription(descriptionValues, L"StylusLength" + to_wstring(i + 1), doubleValue) == true)
            stylusLengthList.push_back(doubleValue);
        else
        {
            err = true;
            break;
        }
    }
    if(err)
        Error(L"Error loading sensor " + sp.Name(), L"Error loading StylusLength values");

    sp.StylusLengths(stylusLengthList);

    // Extension (optional)
    if(GetDoubleValueFromDescription(descriptionValues, L"Extension", doubleValue) == true)
        sp.ExtensionLength(doubleValue);

#ifdef TRACE_RESOURCE_IO
    TRACE(sp.GetDescription(Units::mm));
#endif

    return !HadError();
}

/// <summary> Loads CMMs. </summary>
/// <param name="document"> QIF document </param>
/// <param name="cmmMapping"> Resulting pairs of CMMs and their sensors </param>
/// <returns> True in case of success, otherwise false </returns>
bool QifResourcesDocument::LoadCMMs(qif191::t::CQIFDocument& document, CmmMapping& cmmMapping)
{
    cmmMapping.Clear();

    // Get the CMM node of the document, and also the Tools and Carriages. 
    if(!document.QIFDocument2.exists() || !document.QIFDocument2.first().MeasurementResources.exists() || !document.QIFDocument2.first().MeasurementResources.first().MeasurementDevices.exists())
        return false;
    qif191::t::CMeasurementResourcesType measurementResourcesRoot = document.QIFDocument2.first().MeasurementResources.first();
    qif191::t::CMeasurementDevicesType measurementDevicesRoot = measurementResourcesRoot.MeasurementDevices.first();
    bool hasCarriages = measurementResourcesRoot.Carriages.exists();
    bool hasTools = measurementResourcesRoot.Tools.exists();

    // Loop through all the CMMs (can ignore other nodes)
    unsigned cmmCount = measurementDevicesRoot.CMM.count();
    for(unsigned i = 0; i < cmmCount; i++)
    {
        vector<unsigned> sensorIdList;
        unique_ptr<CmmParameters> cp;
        bool success = LoadCMM(&(measurementDevicesRoot.CMM[i]), hasCarriages ? &(measurementResourcesRoot.Carriages.first()) : nullptr, hasTools ? &(measurementResourcesRoot.Tools.first()) : nullptr, cp, sensorIdList);
        if(success)
            cmmMapping.AddCmm(std::move(cp), std::move(sensorIdList));
    }

    return !HadError();
}

/// <summary> Loads the given CMM and the sensor ids for it. </summary>
/// <param name="cmm"> CMM to load </param>
/// <param name="carriagesRoot"> Carriage root element </param>
/// <param name="toolsRoot"> Tool root element </param>
/// <param name="cp"> Resulting CMM </param>
/// <param name="sensorIdList"> List of sensor identifiers of the CMM </param>
/// <returns> True in case of success, otherwise false </returns>
bool QifResourcesDocument::LoadCMM(qif191::t::CCMMType* cmm, qif191::t::CCarriagesType* carriagesRoot, qif191::t::CToolsType* toolsRoot, unique_ptr<CmmParameters>& cp, vector<unsigned>& sensorIdList)
{
    double value;
    int intValue;
    cp = unique_ptr<CmmParameters>(new CmmParameters());

    // Name. If there isn't one, we will put it as "Unnamed CMM"
    cp->Name(cmm->Name.exists() ? (wstring)cmm->Name.first() : L"");
    if(cp->Name() == L"")
        cp->Name(L"Unnamed CMM");

    // Get all the values in the description
    map<wstring, wstring> descriptionValues;
    GetValuesInDescription(cmm->Description.first(), descriptionValues);

    // CMM Temperatures
    if(cmm->InspectionTemperatures.exists() && cmm->InspectionTemperatures.first().Temperature.count() == 2)
    {
        qif191::t::CTemperaturesType cmmTemps = cmm->InspectionTemperatures.first();
        double t0 = cmm->InspectionTemperatures.first().Temperature[0].Temperature.first();
        double t1 = cmm->InspectionTemperatures.first().Temperature[1].Temperature.first();
        cp->CmmTemperature((t0 + t1) / 2.0);
        cp->CmmTemperatureUncertainty(abs(cp->CmmTemperature() - t0));
    }
    else
        Error(L"Error loading CMM " + cp->Name(), L"Error loading InspectionTemperatures values");

    if(GetDoubleValueFromDescription(descriptionValues, L"CmmLaserAirTemperature", value))
        cp->CmmLaserAirTemperature(value);
    else
        Error(L"Error loading CMM " + cp->Name(), L"Error loading CmmLaserAirTemperature value");

    if(GetDoubleValueFromDescription(descriptionValues, L"CmmLaserAirTemperatureUncertainty", value))
        cp->CmmLaserAirTemperatureUncertainty(value);
    else
        Error(L"Error loading CMM " + cp->Name(), L"Error loading CmmLaserAirTemperatureUncertainty value");

    if(GetDoubleValueFromDescription(descriptionValues, L"CmmLaserAirPressure", value))
        cp->CmmLaserAirPressure(value);
    else
        Error(L"Error loading CMM " + cp->Name(), L"Error loading CmmLaserAirPressure value");

    if(GetDoubleValueFromDescription(descriptionValues, L"CmmLaserAirPressureUncertainty", value))
        cp->CmmLaserAirPressureUncertainty(value);
    else
        Error(L"Error loading CMM " + cp->Name(), L"Error loading CmmLaserAirPressureUncertainty value");

    if(GetDoubleValueFromDescription(descriptionValues, L"CmmLaserAirHumidity", value))
        cp->CmmLaserAirHumidity(value);
    else
        Error(L"Error loading CMM " + cp->Name(), L"Error loading CmmLaserAirHumidity value");

    if(GetDoubleValueFromDescription(descriptionValues, L"CmmLaserAirHumidityUncertainty", value))
        cp->CmmLaserAirHumidityUncertainty(value);
    else
        Error(L"Error loading CMM " + cp->Name(), L"Error loading CmmLaserAirHumidityUncertainty value");

    if(GetIntValueFromDescription(descriptionValues, L"CmmSoftwareCompensation", intValue))
        cp->CmmSoftwareCompensation((CmmSoftwareCompensationType)intValue);
    else
        Error(L"Error loading CMM " + cp->Name(), L"Error loading CmmSoftwareCompensation value");

    // Working volume
    if(cmm->WorkingVolume.exists())
    {
        qif191::t::CWorkingVolumeType cmmWorkingVolume = cmm->WorkingVolume.first();
        vector<double> extents;
        extents.push_back(cmmWorkingVolume.XAxisLength.first());
        extents.push_back(cmmWorkingVolume.YAxisLength.first());
        extents.push_back(cmmWorkingVolume.ZAxisLength.first());
        cp->Extents(extents);
    }
    else
        Error(L"Error loading CMM " + cp->Name(), L"Error loading WorkingVolume value");

    vector<double> zero;
    if(GetDoubleValueFromDescription(descriptionValues, L"Zero0", value))
        zero.push_back(value);
    else
        Error(L"Error loading CMM " + cp->Name(), L"Error loading Zero0 value");
    if(GetDoubleValueFromDescription(descriptionValues, L"Zero1", value))
        zero.push_back(value);
    else
        Error(L"Error loading CMM " + cp->Name(), L"Error loading Zero1 value");
    if(GetDoubleValueFromDescription(descriptionValues, L"Zero2", value))
        zero.push_back(value);
    else
        Error(L"Error loading CMM " + cp->Name(), L"Error loading Zero2 value");
    cp->Zero(zero);

    // CMM geometry type
    if(cmm->MachineGeometry.first().OtherCMMGeometry.exists())
    {
        try
        {
            cp->Type((CmmType)stoi((std::wstring)cmm->MachineGeometry.first().OtherCMMGeometry.first()));
        }
        catch(invalid_argument)
        {
            Error(L"Error loading CMM " + cp->Name(), L"Error parsing OtherCMMGeometry");
        }
    }
    else
    {
        CmmType convertedValue;
        if(ConvertCmmType((qif191::t::CCMMGeometryEnumTypeType::EnumValues)cmm->MachineGeometry.first().CMMGeometryEnum.first().GetEnumerationValue(), convertedValue))
            cp->Type(convertedValue);
        else
            Error(L"Error loading CMM " + cp->Name(), L"Error parsing CMMGeometryEnum");
    }

    // Axis direction
    if(cmm->AxisOrientation.exists() && cmm->AxisOrientation.first().XAxisDirection.exists() && cmm->AxisOrientation.first().YAxisDirection.exists() && cmm->AxisOrientation.first().ZAxisDirection.exists())
    {
        cp->AxisOrientationX(ConvertAxisOrientation((qif191::t::CCMMDirectionEnumTypeType::EnumValues)cmm->AxisOrientation.first().XAxisDirection.first().GetEnumerationValue()));
        cp->AxisOrientationY(ConvertAxisOrientation((qif191::t::CCMMDirectionEnumTypeType::EnumValues)cmm->AxisOrientation.first().YAxisDirection.first().GetEnumerationValue()));
        cp->AxisOrientationZ(ConvertAxisOrientation((qif191::t::CCMMDirectionEnumTypeType::EnumValues)cmm->AxisOrientation.first().ZAxisDirection.first().GetEnumerationValue()));
    }
    else
        Error(L"Error loading CMM " + cp->Name(), L"Error loading AxisOrientation value");

    // CMM Scales
    if(cmm->CMMScales.exists() && cmm->CMMScales.first().XScale.exists() && cmm->CMMScales.first().YScale.exists() && cmm->CMMScales.first().ZScale.exists())
    {
        // X Y and Z scales should have the same values.
        if(cmm->CMMScales.first().XScale.first().ScaleCoefficientOfExpansion.first() != cmm->CMMScales.first().YScale.first().ScaleCoefficientOfExpansion.first() ||
           cmm->CMMScales.first().XScale.first().ScaleCoefficientOfExpansion.first() != cmm->CMMScales.first().ZScale.first().ScaleCoefficientOfExpansion.first() ||
           cmm->CMMScales.first().XScale.first().ScaleCoefficientOfExpansionUncertainty.first() != cmm->CMMScales.first().YScale.first().ScaleCoefficientOfExpansionUncertainty.first() ||
           cmm->CMMScales.first().XScale.first().ScaleCoefficientOfExpansionUncertainty.first() != cmm->CMMScales.first().ZScale.first().ScaleCoefficientOfExpansionUncertainty.first())
            Warning(L"Warning loading CMM " + cp->Name(), L"CMM scales expansion coefficients of the 3 axes are not equal. Defaulting to X Scale values.");

        // Get the values from the X Scale
        cp->CmmExpansionCoefficient(cmm->CMMScales.first().XScale.first().ScaleCoefficientOfExpansion.first());
        cp->CmmExpansionCoefficientUncertainty(cmm->CMMScales.first().XScale.first().ScaleCoefficientOfExpansionUncertainty.first());
        try
        {
            cp->CmmScales((CmmScalesType)stoi((std::wstring)cmm->CMMScales.first().XScale.first().TypeOfScale.first()));
        }
        catch(invalid_argument)
        {
            Error(L"Error loading CMM " + cp->Name(), L"Error loading CMMScales type value");
        }
    }

    // See if there is performance test data
    if(!cmm->ActualAccuracy.exists() && !cmm->NominalAccuracy.exists())
        cp->ActivePerformanceTest(CmmPerformanceTest::None);
    else
    {
        qif191::t::CCMMAccuracyType cmmAccuracy = cmm->ActualAccuracy.exists() ? cmm->ActualAccuracy.first() : cmm->NominalAccuracy.first();

        // Performance test, b89
        if(cmmAccuracy.B89Test.exists())
        {
            CmmErrorB89 b89;
            b89.XLinearAccuracy(cmmAccuracy.B89Test.first().XLinearAccuracy.first());
            b89.YLinearAccuracy(cmmAccuracy.B89Test.first().YLinearAccuracy.first());
            b89.ZLinearAccuracy(cmmAccuracy.B89Test.first().ZLinearAccuracy.first());
            b89.OffsetVolumetricPerformance(cmmAccuracy.B89Test.first().OffsetVolumetricPerformance.first());
            b89.VolumetricPerformance(cmmAccuracy.B89Test.first().VolumetricPerformance.first());
            b89.Repeatability(cmmAccuracy.B89Test.first().Repeatability.first());
            cp->B89Results(&b89);
            cp->ActivePerformanceTest(CmmPerformanceTest::B89);
        }

        // Performance test, ISO 10360
        if(cmmAccuracy.ISO10360Test.exists())
        {
            CmmErrorIso10360 iso10360;

            // Test result values
            if(cmmAccuracy.ISO10360Test.first().MaxErrorConstant.exists())
            {
                iso10360.ErrorOfIndicationType(CmmErrorIso10360::ErrorType::OneValue);
                iso10360.ErrorOfIndicationValue3(cmmAccuracy.ISO10360Test.first().MaxErrorConstant.first());
            }
            else if(cmmAccuracy.ISO10360Test.first().LinearError.exists())
            {
                iso10360.ErrorOfIndicationType(CmmErrorIso10360::ErrorType::TwoValues);
                iso10360.ErrorOfIndicationValue1(cmmAccuracy.ISO10360Test.first().LinearError.first().BaseError.first());
                iso10360.ErrorOfIndicationValue2(cmmAccuracy.ISO10360Test.first().LinearError.first().ErrorRate.first());
            }
            else if(cmmAccuracy.ISO10360Test.first().LesserError.exists())
            {
                iso10360.ErrorOfIndicationType(CmmErrorIso10360::ErrorType::ThreeValues);
                iso10360.ErrorOfIndicationValue1(cmmAccuracy.ISO10360Test.first().LesserError.first().LinearError.first().BaseError.first());
                iso10360.ErrorOfIndicationValue2(cmmAccuracy.ISO10360Test.first().LesserError.first().LinearError.first().ErrorRate.first());
                iso10360.ErrorOfIndicationValue3(cmmAccuracy.ISO10360Test.first().LesserError.first().MaxErrorConstant.first());
            }
            else Error(L"Error loading CMM " + cp->Name(), L"Error loading ISO 10360 mpe values");

            // Artifact type, positions, and stacking order
            if(GetIntValueFromDescription(descriptionValues, L"IsoArtifact", intValue))
                iso10360.Artifact((CmmErrorIso10360::ArtifactType)intValue);
            else Error(L"Error loading CMM " + cp->Name(), L"Error loading ISO 10360 IsoArtifact values");
            for(int i = 0; i < iso10360.ArtifactPositionCount(); i++)
            {
                if(GetIntValueFromDescription(descriptionValues, L"IsoArtifactPosition" + to_wstring(i + 1), intValue))
                    iso10360.ArtifactPositionValue(i, (CmmErrorIso10360::ArtifactPosition)intValue);
                else Error(L"Error loading CMM " + cp->Name(), L"Error loading ISO 10360 IsoArtifactPosition values");

                if(iso10360.Artifact() == CmmErrorIso10360::ArtifactType::GageBlocks)
                {
                    if(GetIntValueFromDescription(descriptionValues, L"IsoArtifactStackingOrder" + to_wstring(i + 1), intValue))
                        iso10360.GageBlockStackingValue(i, (CmmErrorIso10360::GageBlockStacking)intValue);
                    else Error(L"Error loading CMM " + cp->Name(), L"Error loading ISO 10360 IsoArtifactStackingOrder values");
                }
            }
            cp->Iso10360Results(&iso10360);
            cp->ActivePerformanceTest(CmmPerformanceTest::Iso10360Cmm);
        }

        // FPS CMM data
        // TODO
    }

    // Rotary Table
    cp->HasRotaryTable(false);
    if(cmm->RotaryTable.exists())
    {
        cp->HasRotaryTable(true);

        // Get location, direction, and zero index direction
        double x, y, z;
        GetPointValues(&cmm->RotaryTable.first().LocationOnCMM.first(), x, y, z);
        cp->RotaryTableXOrigin(x);
        cp->RotaryTableYOrigin(y);
        cp->RotaryTableZOrigin(z);
        GetUnitVectorValues(&(cmm->RotaryTable.first().AxisDirection.first()), x, y, z);
        vector<double> axisDir;
        axisDir.push_back(x);
        axisDir.push_back(y);
        axisDir.push_back(z);
        cp->RotaryTableAxisDirection(axisDir);
        GetUnitVectorValues(&(cmm->RotaryTable.first().ZeroIndexDirection.first()), x, y, z);
        vector<double> zeroIndex;
        zeroIndex.push_back(x);
        zeroIndex.push_back(y);
        zeroIndex.push_back(z);
        cp->RotaryTableAxisDirection(zeroIndex);

        // Get radius and error values
        cp->RotaryTableRadius(cmm->RotaryTable.first().TableRadius.first());
        if(cmm->RotaryTable.first().TableErrors.exists())
        {
            cp->RotaryTableAxialError(cmm->RotaryTable.first().TableErrors.first().AxialError.first());
            cp->RotaryTableRadialError(cmm->RotaryTable.first().TableErrors.first().RadialError.first());
            cp->RotaryTableTangentialError(cmm->RotaryTable.first().TableErrors.first().TangentialError.first());
        }
        else Error(L"Error loading CMM " + cp->Name(), L"Error loading rotary table error values");
    }

    // Get sensor ids
    // First, look through all the tools on the CMM itself.
    if(cmm->ToolIds.exists())
    {
        for(unsigned i = 0; i < cmm->ToolIds.first().N; i++)
        {
            unsigned toolId = cmm->ToolIds.first().Id[i];
            GetSensorsOfTool(toolsRoot, toolId, sensorIdList);
        }
    }
    // Next, look through all the Tools of the carriages
    if(cmm->CarriageIds.exists())
    {
        for(unsigned i = 0; i < cmm->CarriageIds.first().N; i++)
        {
            unsigned carriageId = cmm->CarriageIds.first().Id[i];
            GetSensorsOfCarriage(carriagesRoot, toolsRoot, carriageId, sensorIdList);
        }
    }

    // Done
#ifdef TRACE_RESOURCE_IO
    TRACE("Sensor IDs:");
    if(sensorIdList.empty())
        TRACE("  (empty)");
    for each(unsigned id in sensorIdList)
        TRACE(id);
    TRACE(cp->GetDescription(Units::mm));
#endif
    return !HadError();
}

/// <summary>
/// Convert between a CmmType to a qif191::t::CCMMGeometryEnumTypeType.
/// Here is the mapping:
///     MovingBridge               k_BRIDGEMOVINGBRIDGE     
///     FixedBridge                k_BRIDGEMOVINGTABLE    
///     Column                     k_COLUMN     
///     FixedTableCantilever       k_CANTILEVER             
///     MovingRamHorizontalArm     k_HORIZONTALARMMOVINGARM                  
///     MovingTableHorizontalArm   k_HORIZONTALARMMOVINGTABLE                 
///     Gantry                     k_GANTRY
///     LShapedBridge              (none)
///     FixedTableHorizontalArm    (none)
///     MovingTableCantileverArm   (none)
/// </summary>
/// <param name="type"> CMM type to convert  </param>
/// <returns> Converted type </returns>
qif191::t::CCMMGeometryEnumTypeType::EnumValues QifResourcesDocument::ConvertCmmType(CmmType type)
{
    switch(type)
    {
    case CmmType::MovingBridge:
        return qif191::t::CCMMGeometryEnumTypeType::k_BRIDGEMOVINGBRIDGE;
    case CmmType::FixedBridge:
        return qif191::t::CCMMGeometryEnumTypeType::k_BRIDGEMOVINGTABLE;
    case CmmType::Column:
        return qif191::t::CCMMGeometryEnumTypeType::k_COLUMN;
    case CmmType::FixedTableCantilever:
        return qif191::t::CCMMGeometryEnumTypeType::k_CANTILEVER;
    case CmmType::MovingRamHorizontalArm:
        return qif191::t::CCMMGeometryEnumTypeType::k_HORIZONTALARMMOVINGARM;
    case CmmType::MovingTableHorizontalArm:
        return qif191::t::CCMMGeometryEnumTypeType::k_HORIZONTALARMMOVINGTABLE;
    case CmmType::Gantry:
        return qif191::t::CCMMGeometryEnumTypeType::k_GANTRY;
    case CmmType::LShapedBridge:
    case CmmType::FixedTableHorizontalArm:
    case CmmType::MovingTableCantileverArm:
        break;
    }
    return qif191::t::CCMMGeometryEnumTypeType::Invalid;
}
// Returns false if the type is "Invalid"

/// <summary> Converts CMM type from XML type to internal one. </summary>
/// <param name="type"> XML type </param>
/// <param name="convertedValue"> Internal type </param>
/// <returns> True in case of success, otherwise false </returns>
bool QifResourcesDocument::ConvertCmmType(qif191::t::CCMMGeometryEnumTypeType::EnumValues type, CmmType& convertedValue)
{
    switch(type)
    {
    case qif191::t::CCMMGeometryEnumTypeType::Invalid:
        return false;
    case qif191::t::CCMMGeometryEnumTypeType::k_CANTILEVER:
        convertedValue = CmmType::FixedTableCantilever;
        return true;
    case qif191::t::CCMMGeometryEnumTypeType::k_BRIDGEMOVINGBRIDGE:
        convertedValue = CmmType::MovingBridge;
        return true;
    case qif191::t::CCMMGeometryEnumTypeType::k_BRIDGEMOVINGTABLE:
        convertedValue = CmmType::FixedBridge;
        return true;
    case qif191::t::CCMMGeometryEnumTypeType::k_COLUMN:
        convertedValue = CmmType::Column;
        return true;
    case qif191::t::CCMMGeometryEnumTypeType::k_GANTRY:
        convertedValue = CmmType::Gantry;
        return true;
    case qif191::t::CCMMGeometryEnumTypeType::k_HORIZONTALARMMOVINGARM:
        convertedValue = CmmType::MovingRamHorizontalArm;
        return true;
    case qif191::t::CCMMGeometryEnumTypeType::k_HORIZONTALARMMOVINGTABLE:
        convertedValue = CmmType::MovingTableHorizontalArm;
        return true;
    }
    throw invalid_argument("Invalid argument in QifResourcesDocument::ConvertCmmType()");
}

/// <summary>
/// Convert between axis orientations. Here is the mapping:
///     PlusA   k_RIGHT
///     PlusB   k_BACK
///     PlusC   k_UP
///     MinusA  k_LEFT
///     MinusB  k_FRONT
///     MinusC  k_DOWN
/// </summary>
/// <param name="o"> Orientation to convert </param>
/// <returns> Converter orientation </returns>
qif191::t::CCMMDirectionEnumTypeType::EnumValues QifResourcesDocument::ConvertAxisOrientation(CmmAxisOrientation o)
{
    switch(o)
    {
    case CmmAxisOrientation::PlusA:
        return qif191::t::CCMMDirectionEnumTypeType::k_RIGHT;
    case CmmAxisOrientation::PlusB:
        return qif191::t::CCMMDirectionEnumTypeType::k_BACK;
    case CmmAxisOrientation::PlusC:
        return qif191::t::CCMMDirectionEnumTypeType::k_UP;
    case CmmAxisOrientation::MinusA:
        return qif191::t::CCMMDirectionEnumTypeType::k_LEFT;
    case CmmAxisOrientation::MinusB:
        return qif191::t::CCMMDirectionEnumTypeType::k_FRONT;
    case CmmAxisOrientation::MinusC:
        return qif191::t::CCMMDirectionEnumTypeType::k_DOWN;
    }
    throw invalid_argument("Invalid argument in QifResourcesDocument::ConvertAxisOrientation()");
}

/// <summary> Convert axis orientations from XML type to internal one. </summary>
/// <param name="o"> XML axis orientation </param>
/// <returns> Resulting axis orientation </returns>
CmmAxisOrientation QifResourcesDocument::ConvertAxisOrientation(qif191::t::CCMMDirectionEnumTypeType::EnumValues o)
{
    switch(o)
    {
    case qif191::t::CCMMDirectionEnumTypeType::k_RIGHT:
        return CmmAxisOrientation::PlusA;
    case qif191::t::CCMMDirectionEnumTypeType::k_BACK:
        return CmmAxisOrientation::PlusB;
    case qif191::t::CCMMDirectionEnumTypeType::k_UP:
        return CmmAxisOrientation::PlusC;
    case qif191::t::CCMMDirectionEnumTypeType::k_LEFT:
        return CmmAxisOrientation::MinusA;
    case qif191::t::CCMMDirectionEnumTypeType::k_FRONT:
        return CmmAxisOrientation::MinusB;
    case qif191::t::CCMMDirectionEnumTypeType::k_DOWN:
        return CmmAxisOrientation::MinusC;
    }
    throw invalid_argument("Invalid argument in QifResourcesDocument::ConvertAxisOrientation()");
}

/// <summary>
/// Takes the string found in the Description element of either the CMM or Probe and breaks it down into a Dictionary of key value pairs
/// following the pattern:
/// name1=value1;name2=value2...
/// </summary>
/// <param name="descriptionElementContents"> Description string </param>
/// <param name="table"> Resulting mapping </param>
void QifResourcesDocument::GetValuesInDescription(wstring descriptionElementContents, map<wstring, wstring>& table)
{
    // Get the list of all key/value pairs
    vector<wstring> pairList;
    SplitString(descriptionElementContents, L';', pairList);

    // Loop through all key/value pairs and build up the map
    vector<wstring> keyValuePair;
    for(vector<wstring>::iterator it = pairList.begin(); it != pairList.end(); it++)
    {
        SplitString(*it, L'=', keyValuePair, false);
        ASSERT(keyValuePair.size() == 2);
        if(keyValuePair.size() != 2)
            throw invalid_argument("Invalid key/value pair in a Description element found");
        table[keyValuePair[0]] = keyValuePair[1];
    }
}

/// <summary> Returns a list of the performance test values under the given key.  </summary>
/// <param name="key"> Key to find </param>
/// <param name="descriptionValues"> Description values </param>
/// <param name="values"> Returns an empty list if there is no such key, or the key is there, but value is empty </param>
void QifResourcesDocument::GetPerformanceTestValues(wstring key, const map<wstring, wstring>& descriptionValues, vector<double>& values)
{
    values.clear();

    // Get the performance test we are looking for
    map<wstring, wstring>::const_iterator keyValuePair = descriptionValues.find(key);
    if(keyValuePair != descriptionValues.end())
    {
        // Parse all the string values
        vector<wstring> stringValues;
        SplitString(keyValuePair->second, L',', stringValues);
        for(vector<wstring>::iterator it = stringValues.begin(); it != stringValues.end(); it++)
        {
            try
            {
                values.push_back(stod(*it));
            }
            catch(invalid_argument)
            {
                // Couldn't load
                Warning(L"Unable to load performance test values from Description element", L"Found the following string: " + keyValuePair->second);
                values.clear();
            }
        }
    }
}

/// <summary> Appends the sensors found on the given carriage to the given List<double> </summary>
/// <param name="carriagesRoot"> Carriage root element </param>
/// <param name="toolsRoot"> Tool root element </param>
/// <param name="carriageId"> Carriage identifier </param>
/// <param name="sensorIdList"> List of sensor identifiers </param>
void QifResourcesDocument::GetSensorsOfCarriage(qif191::t::CCarriagesType* carriagesRoot, qif191::t::CToolsType* toolsRoot, unsigned carriageId, std::vector<unsigned>& sensorIdList)
{
    // Loop through all carriages in root, searching for "carriageId"
    for(unsigned i = 0; i < carriagesRoot->Carriage.count(); i++)
    {
        if(carriagesRoot->Carriage[i].id == carriageId)
        {
            // Get all the sensors from all the tools on this carriage
            for(unsigned j = 0; j < carriagesRoot->Carriage[i].ToolIds.first().N; j++)
            {
                GetSensorsOfTool(toolsRoot, carriagesRoot->Carriage[i].ToolIds.first().Id[j], sensorIdList);
            }
        }
    }
}

/// <summary> Appends the sensors found on the given tool to the given list of numbers. </summary>
/// <param name="toolsRoot"> Tool root element </param>
/// <param name="toolId"> Tool identifier </param>
/// <param name="sensorIdList"> Resulting array of sensor identifiers </param>
void QifResourcesDocument::GetSensorsOfTool(qif191::t::CToolsType* toolsRoot, unsigned toolId, vector<unsigned>& sensorIdList)
{
    // Loop through all tools in root, searching for "toolId"
    for(unsigned i = 0; i < toolsRoot->Tool.count(); i++)
    {
        if(toolsRoot->Tool[i].id == toolId)
        {
            // Add all the sensors on this tool
            for(unsigned j = 0; j < toolsRoot->Tool[i].SensorIds.first().N; j++)
            {
                unsigned sensorId = toolsRoot->Tool[i].SensorIds.first().Id[j];
                vector<unsigned>::iterator it = std::find(sensorIdList.begin(), sensorIdList.end(), sensorId);
                if(it == sensorIdList.end())
                    sensorIdList.push_back(sensorId);
            }
        }
    }
}

/// <summary> QIF identifiers </summary>
static unsigned __qif_id__ = 1;

/// <summary> Resets QIF identifier generator for a new file. </summary>
void QifResourcesDocument::ResetQifIds()
{
    __qif_id__ = 1;
}

/// <summary> Generates the next QIF identifier. </summary>
/// <returns> Identifier </returns>
unsigned QifResourcesDocument::GetQifId()
{
    return __qif_id__++;
}


///////////////////////////////////////////////////////////////////////////////
// SplitString
// Splits the given string according to the given delimiter


/// <summary> Splits a string by the specified delimiter. </summary>
/// <param name="str"> String to split </param>
/// <param name="delim"> Delimiter </param>
/// <param name="tokenList"> Resulting tokens </param>
/// <param name="skipEmptyTokens"> Determines if empty tokens are allowed </param>
void QifResourcesDocument::SplitString(const wstring& str, wchar_t delim, vector<wstring>& tokenList, bool skipEmptyTokens /*= true*/)
{
    tokenList.clear();
    wstringstream ss(str);
    wstring token;
    while(getline(ss, token, delim))
    {
        if(skipEmptyTokens && token.empty())
            continue;
        tokenList.push_back(token);
    }
}

/// <summary> Gets an integer value from the given description mapping with the given key. </summary>
/// <param name="descriptionValues"> Description map </param>
/// <param name="key"> Key </param>
/// <param name="value"> Value </param>
/// <returns> False if it doesn't exist, or couldn't be parsed, otherwise true </returns>
bool QifResourcesDocument::GetIntValueFromDescription(const map<wstring, wstring>& descriptionValues, const wstring& key, int& value)
{
    map<wstring, wstring>::const_iterator it = descriptionValues.find(key);
    if(it != descriptionValues.end())
    {
        try
        {
            value = std::stoi(it->second);
            return true;
        }
        catch(invalid_argument) {}
    }
    return false;
}

/// <summary> Gets a double value from the given description mapping with the given key. </summary>
/// <param name="descriptionValues"> Description map </param>
/// <param name="key"> Key </param>
/// <param name="value"> Value </param>
/// <returns> False if it doesn't exist, or couldn't be parsed, otherwise true </returns>
bool QifResourcesDocument::GetDoubleValueFromDescription(const map<wstring, wstring>& descriptionValues, const wstring& key, double& value)
{
    auto it = descriptionValues.find(key);
    if(it != descriptionValues.end())
    {
        try
        {
            value = std::stod(it->second);
            return true;
        }
        catch(invalid_argument) {}
    }
    return false;
}

/// <summary> Adds an error to our list of errors. </summary>
/// <param name="errorMessage"> Error message </param>
/// <param name="errorMessageDetails"> Error details </param>
void QifResourcesDocument::Error(wstring errorMessage, wstring errorMessageDetails)
{
    _errorList.push_back(errorMessage);
    _errorDetailsList.push_back(errorMessageDetails);
}

/// <summary> Adds a warning to our list of warnings. </summary>
/// <param name="warningMessage"> Warning message </param>
/// <param name="warningMessageDetails"> Warning details </param>
void QifResourcesDocument::Warning(wstring warningMessage, wstring warningMessageDetails)
{
    _warningList.push_back(warningMessage);
    _warningDetailsList.push_back(warningMessageDetails);
}

}

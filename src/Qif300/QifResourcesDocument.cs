///////////////////////////////////////////////////////////////////////////////
///
/// Copyright 2018-2020, Capvidia, Metrosage, and project contributors
/// https://www.capvidia.com/
/// 
/// This software is provided for free use to the QIF Community under the 
/// following license:
/// 
/// Boost Software License - Version 1.0 - August 17th, 2003
/// https://www.boost.org/LICENSE_1_0.txt
/// 
/// Permission is hereby granted, free of charge, to any person or organization
/// obtaining a copy of the software and accompanying documentation covered by
/// this license (the "Software") to use, reproduce, display, distribute,
/// execute, and transmit the Software, and to prepare derivative works of the
/// Software, and to permit third-parties to whom the Software is furnished to
/// do so, all subject to the following:
/// 
/// The copyright notices in the Software and this entire statement, including
/// the above license grant, this restriction and the following disclaimer,
/// must be included in all copies of the Software, in whole or in part, and
/// all derivative works of the Software, unless such copies or derivative
/// works are solely in the form of machine-executable object code generated by
/// a source language processor.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
/// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
/// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
/// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.

using Qif;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml;
using Qif300.Units;

namespace Qif300
{
    /// <summary> Provides reading/writing CMM and sensor parameters from QIF 3.0 documents. </summary>
    public class QifResourcesDocument : IResourcesDocument
    {
        /// <summary> Constructor </summary>
        /// <param name="path"> File path </param>
        public QifResourcesDocument(string path)
        {
            Path = path;
        }

        /// <summary> Gets or sets QPID of the QIF document </summary>
        public string Qpid { get; set; }

        /// <summary> Gets a value indicating whether there were warnings during loading/saving </summary>
        public bool HadWarning => Errors.Warnings.Count > 0;

        /// <summary> Gets a value indicating whether there were errors during loading/saving </summary>
        public bool HadError => Errors.Errors.Count > 0;

        /// <summary> Gets error list </summary>
        public IReadOnlyList<string> ErrorList => Errors.Errors;

        /// <summary> Gets list of error details corresponding to error in the ErrorList </summary>
        public IReadOnlyList<string> ErrorDetailsList => Errors.ErrorDetails;

        /// <summary> Gets warning list </summary>
        public IReadOnlyList<string> WarningList => Errors.Warnings;

        /// <summary> Gets list of warning details corresponding to warning in the WarningList </summary>
        public IReadOnlyList<string> WarningDetailsList => Errors.WarningDetails;

        /// <summary> Error container </summary>
        private LoadingErrors Errors { get; } = new LoadingErrors();

        /// <summary> Loads CMM parameters from QIF file </summary>
        /// <returns> Loaded CMM parameters </returns>
        public IReadOnlyList<CmmParameters> Load()
        {
            Errors.Clear();

            // parse QIF
            var serializer = new MeasurementResourcesSerializer();
            serializer.Deserialize(Path);

            // check whether there are measurement resources
            if (serializer.MeasurementResources.MeasurementDevices == null)
                return null;

            // load QPID
            Qpid = serializer.Qpid;

            // load units
            var units = LoadUnits(serializer.FileUnits);

            // load Sensors
            var sensors = LoadSensors(serializer.MeasurementResources);

            // load CMMs from parsed data
            var cmms = LoadCmms(serializer.MeasurementResources, sensors, units);
            return HadError ? null : cmms;
        }

        /// <summary> Saves the specified CMM parameters to the QIF file </summary>
        /// <param name="cmmParameters"> CMM parameters to save </param>
        /// <returns> True in case of success, otherwise false </returns>
        public bool Save(IEnumerable<CmmParameters> cmmParameters)
        {
            Errors.Clear();

            var measurementResources = new qif30.MeasurementResourcesType();

            // create document and XML object factory
            var xmlDocument = new XmlDocument();
            var xmlObjectFactory = new XmlObjectFactory(xmlDocument);

            // save sensors and keep mapping from sensor object to ID in QIF
            var mapSensorIds = new Dictionary<SensorParameters, uint>();
            var sensors = SaveSensors(mapSensorIds, CollectSensors(cmmParameters), xmlObjectFactory);
            measurementResources.DetachableSensors = new qif30.DetachableSensorsType()
            {
                DetachableSensor = sensors,
                n = (uint)sensors.Length
            };

            // save CMMs
            var cmms = SaveCmms(cmmParameters, mapSensorIds, xmlObjectFactory);
            measurementResources.MeasurementDevices = new qif30.MeasurementDevicesType()
            {
                MeasurementDevice = cmms,
                n = (uint)cmms.Length
            };

            // save units
            var units = SaveUnits();

            if (HadError)
                return false;

            try
            {
                // save XML structure to file
                var serializer = new MeasurementResourcesSerializer()
                {
                    MeasurementResources = measurementResources,
                    FileUnits = units,
                    Qpid = Qpid
                };
                serializer.Serialize(Path);
                return true;
            }
            catch (Exception e)
            {
                Errors.AddError("XML Error", e.Message);
                return false;
            }
        }

        /// <summary> Loads units </summary>
        /// <param name="fileUnits"> QIF file units </param>
        /// <returns> Loaded units </returns>
        private FileUnits LoadUnits(qif30.FileUnitsType fileUnits)
        {
            var loader = new UnitLoader(fileUnits, Errors);
            return new FileUnits()
            {
                LengthConverter = loader.LoadLinearConverters(),
                PressureConverter = loader.LoadPressureConveters(),
                TemperatureConverter = loader.LoadTemperatureConveters()
            };
        }

        /// <summary> Creates QIF file unit object. </summary>
        /// <returns> QIF file unit object </returns>
        private qif30.FileUnitsType SaveUnits()
        {
            return new qif30.FileUnitsType
            {
                PrimaryUnits = new qif30.PrimaryUnitsType()
                {
                    LinearUnit = new qif30.LinearUnitType() { UnitName = "mm" },
                    PressureUnit = new qif30.PressureUnitType() { UnitName = "kpa" },
                    TemperatureUnit = new qif30.TemperatureUnitType() { UnitName = "celsius" }
                }
            };
        }

        /// <summary> Saves the specified CMM parameters to QIF structures. </summary>
        /// <param name="cmms"> CMM parameters </param>
        /// <param name="mapSensorIds"> Map from sensor parameters to their corresponding ID in QIF </param>
        /// <param name="xmlObjectFactory"> XML object factory </param>
        /// <returns> Resulting array of QIF CMM structures </returns>
        private qif30.CartesianCMMType[] SaveCmms(IEnumerable<CmmParameters> cmms, IDictionary<SensorParameters, uint> mapSensorIds, XmlObjectFactory xmlObjectFactory)
        {
            int n = cmms.Count();
            int i = 0;
            var res = new qif30.CartesianCMMType[n];
            foreach (var cmm in cmms)
                res[i++] = SaveCmm(cmm, mapSensorIds, xmlObjectFactory);
            return res;
        }

        /// <summary> Saves the specified CMM to QIF structures. </summary>
        /// <param name="cmm"> CMM </param>
        /// <param name="mapSensorIds"> Map from sensor parameters to their corresponding ID in QIF </param>
        /// <param name="xmlObjectFactory"> XML object factory </param>
        /// <returns> QIF CMM structure object </returns>
        private qif30.CartesianCMMType SaveCmm(CmmParameters cmm, IDictionary<SensorParameters, uint> mapSensorIds, XmlObjectFactory xmlObjectFactory)
        {
            var xmlCmm = xmlObjectFactory.CreateCartesianCmm();

            // Name
            xmlCmm.Name = cmm.Name;

            // Lower extent
            for (int i = 0; i < 3; ++i)
                xmlCmm.Attributes.AddDecAttribute($"LowerExtent{Utilities.CoordinateNames[i]}", cmm.Zero[i]);

            // Extends (Working volume axis lengths)
            xmlCmm.WorkingVolume = new qif30.CartesianWorkingVolumeType()
            {
                XAxisLength = Utilities.CreateLinearValue(cmm.Extents[0]),
                YAxisLength = Utilities.CreateLinearValue(cmm.Extents[1]),
                ZAxisLength = Utilities.CreateLinearValue(cmm.Extents[2])
            };

            // Type
            if (Utilities.CmmTypeMap.Values.Contains(cmm.Type))
                xmlCmm.CMMGeometry = new qif30.CartesianCMMGeometryType() { Item = Utilities.CmmTypeMap.FirstOrDefault(t => t.Value == cmm.Type).Key };
            else
                Errors.AddError(cmm, "Error saving type of CMM");

            // Axis orientations
            xmlCmm.CMMAxisDirections = SaveAxisDirections(cmm);

            // Performance tests
            var b89Results = SaveB89Results(cmm.B89Results);
            var isoResults = SaveIsoResults(cmm);

            // Save performance test so that the active one is the first in the accuracies array
            var activeTest = cmm.ActivePerformanceTest;
            if (activeTest == CmmPerformanceTest.B89)
                xmlCmm.Accuracies = SavePerformanceTests(new List<qif30.CMMAccuracyTestBaseType>() { b89Results, isoResults });
            else if (activeTest == CmmPerformanceTest.Iso10360)
                xmlCmm.Accuracies = SavePerformanceTests(new List<qif30.CMMAccuracyTestBaseType>() { isoResults, b89Results });
            else if (activeTest != CmmPerformanceTest.None)
                Errors.AddError(cmm, "Error saving active performance tests");

            // Sensors
            xmlCmm.SensorIds = SaveSensors(cmm, mapSensorIds);

            // CMM Scales
            try
            {
                var scaleType = Utilities.CmmScalesMap.First(s => s.Value == cmm.CmmScales).Key;
                var scale = new qif30.MeasurementDeviceScaleType()
                {
                    TypeOfScale = new qif30.TypeOfScaleType() { Item = scaleType },
                    ScaleCoefficientOfExpansion = (decimal)cmm.CmmExpansionCoefficient,
                    ScaleCoefficientOfExpansionUncertainty = (decimal)cmm.CmmExpansionCoefficientUncertainty,
                    ScaleCoefficientOfExpansionSpecified = true,
                    ScaleCoefficientOfExpansionUncertaintySpecified = true
                };

                xmlCmm.Scales = new qif30.CartesianMeasurementDeviceScalesType()
                {
                    XScale = scale,
                    YScale = scale,
                    ZScale = scale
                };
            }
            catch (InvalidOperationException)
            {
                Errors.AddError(cmm, "Error saving CMM scale type");
            }

            // CMM Temperature
            xmlCmm.Attributes.AddDecAttribute("CMMTemperature", cmm.CmmTemperature);

            // CMM temperature uncertainty
            xmlCmm.Attributes.AddDecAttribute("CmmTemperatureUncertainty", cmm.CmmTemperatureUncertainty);

            // Air temperature/uncertainty
            // Air pressure/uncertainty
            // Air humidity/uncertainty
            xmlCmm.EnvironmentalRange = new qif30.EnvironmentalRangeType()
            {
                MinAmbientTemperature = Utilities.CreateTemperatureValue(cmm.CmmLaserAirTemperature - cmm.CmmLaserAirTemperatureUncertainty),
                MaxAmbientTemperature = Utilities.CreateTemperatureValue(cmm.CmmLaserAirTemperature + cmm.CmmLaserAirTemperatureUncertainty),
                MinAmbientAirPressure = Utilities.CreatePressureValueType(cmm.CmmLaserAirPressure - cmm.CmmLaserAirPressureUncertainty),
                MaxAmbientAirPressure = Utilities.CreatePressureValueType(cmm.CmmLaserAirPressure + cmm.CmmLaserAirPressureUncertainty),
                MinAmbientRelativeHumidity = Utilities.CreateDecimal(cmm.CmmLaserAirHumidity - cmm.CmmLaserAirHumidityUncertainty),
                MaxAmbientRelativeHumidity = Utilities.CreateDecimal(cmm.CmmLaserAirHumidity + cmm.CmmLaserAirHumidityUncertainty)
            };

            // Software compensation
            xmlCmm.Attributes.AddStringAttribute("SoftwareCompensation", Utilities.CmmSoftwareCompensationStrMap.ToString(cmm.CmmSoftwareCompensation));

            // Rotary table
            if (cmm.HasRotaryTable)
            {
                xmlCmm.RotaryTable = new qif30.RotaryTableType()
                {
                    AxisDirection = Utilities.CreateUnitVector(new T3<double>(cmm.RotaryTableAxisDirection)),
                    LocationOnCMM = Utilities.CreatePoint(new T3<double>(cmm.RotaryTableXOrigin, cmm.RotaryTableYOrigin, cmm.RotaryTableZOrigin)),
                    ZeroIndexDirection = Utilities.CreateUnitVector(new T3<double>(cmm.RotaryTableZeroIndexDirection)),
                    TableRadius = Utilities.CreateLinearValue(cmm.RotaryTableRadius),
                    TableErrors = new qif30.TableErrorsType()
                    {
                        AxialError = Utilities.CreateLinearValue(cmm.RotaryTableAxialError),
                        RadialError = Utilities.CreateLinearValue(cmm.RotaryTableRadialError),
                        TangentialError = Utilities.CreateLinearValue(cmm.RotaryTableTangentialError)
                    }
                };
            }

            return xmlCmm;
        }

        /// <summary> Saves sensors of the specified CMM to QIF array reference structure </summary>
        /// <param name="cmm"> CMM </param>
        /// <param name="mapSensorIds"> Map from sensors to QIF identifiers </param>
        /// <returns> Array reference of CMM sensors </returns>
        private qif30.ArrayReferenceType SaveSensors(CmmParameters cmm, IDictionary<SensorParameters, uint> mapSensorIds)
        {
            // convert sensors to IDs using the specified map
            int n = cmm.SensorParameterList.Count;
            var sensors = new List<qif30.QIFReferenceType>(n);
            for (int i = 0; i < n; ++i)
            {
                var sensor = cmm.SensorParameterList[i];

                var a = sensor == mapSensorIds.FirstOrDefault().Key;

                if (mapSensorIds.TryGetValue(sensor, out var id))
                    sensors.Add(new qif30.QIFReferenceType() { Value = id });
                else
                    Errors.AddError(cmm, $"Error saving the '{sensor.Name}' sensor in the sensor list of the CMM");
            }

            // create array reference
            return new qif30.ArrayReferenceType()
            {
                Id = sensors.ToArray(),
                n = (uint)sensors.Count
            };
        }

        /// <summary> Saves the specified performance test to QIF accuracies structure </summary>
        /// <param name="tests"> Performance tests to save </param>
        /// <returns> QIF accuracies structure </returns>
        private qif30.CartesianCMMAccuraciesType SavePerformanceTests(IReadOnlyList<qif30.CMMAccuracyTestBaseType> tests)
        {
            int n = tests.Count;
            var res = new qif30.CartesianCMMAccuracyType[n];
            for (int i = 0; i < n; ++i)
                res[i] = new qif30.CartesianCMMAccuracyType() { CartesianCMMAccuracyTest = tests[i] };

            return new qif30.CartesianCMMAccuraciesType()
            {
                CartesianCMMAccuracy = res,
                n = (uint)n
            };
        }

        /// <summary> Saves axis direction of the specified CMM to corresponding QIF structure </summary>
        /// <param name="cmm"> CMM </param>
        /// <returns> QIF Axis directions structure </returns>
        private qif30.CartesianCMMAxisDirectionsType SaveAxisDirections(CmmParameters cmm)
        {
            var res = new qif30.CartesianCMMAxisDirectionsType();
            if (Utilities.AxisDirectionMap.Values.Contains(cmm.AxisOrientationX))
                res.XAxisDirection = Utilities.AxisDirectionMap.FirstOrDefault(d => d.Value == cmm.AxisOrientationX).Key;
            else
                res = null;

            if (res != null && Utilities.AxisDirectionMap.Values.Contains(cmm.AxisOrientationY))
                res.YAxisDirection = Utilities.AxisDirectionMap.FirstOrDefault(d => d.Value == cmm.AxisOrientationY).Key;
            else
                res = null;

            if (res != null && Utilities.AxisDirectionMap.Values.Contains(cmm.AxisOrientationZ))
                res.ZAxisDirection = Utilities.AxisDirectionMap.FirstOrDefault(d => d.Value == cmm.AxisOrientationZ).Key;
            else
                res = null;

            if (res == null)
                Errors.AddError(cmm, "Error saving axis directions");
            return res;
        }

        /// <summary> Saves ISO performance test of the specified CMM to the corresponding QIF structure. </summary>
        /// <param name="cmm"> CMM </param>
        /// <returns> QIF structure of ISO performance test </returns>
        private qif30.ISO10360TestType SaveIsoResults(CmmParameters cmm)
        {
            var res = new qif30.ISO10360TestType();

            var results = cmm.Iso10360Results;
            switch (results.ErrorOfIndicationType)
            {
                case CmmErrorIso10360.ErrorType.OneValue:
                    res.Item = Utilities.CreateLinearValue(results.ErrorOfIndicationValue3);
                    break;
                case CmmErrorIso10360.ErrorType.TwoValues:
                    res.Item = new qif30.LinearErrorType()
                    {
                        BaseError = Utilities.CreateLinearValue(results.ErrorOfIndicationValue1),
                        ErrorRate = (decimal)results.ErrorOfIndicationValue2
                    };
                    break;
                case CmmErrorIso10360.ErrorType.ThreeValues:
                    res.Item = new qif30.LesserErrorType()
                    {
                        LinearError = new qif30.LinearErrorType()
                        {
                            BaseError = Utilities.CreateLinearValue(results.ErrorOfIndicationValue1),
                            ErrorRate = (decimal)results.ErrorOfIndicationValue2
                        },
                        MaxErrorConstant = Utilities.CreateLinearValue(results.ErrorOfIndicationValue3)
                    };
                    break;
                default:
                    Errors.AddError(cmm, "Error saving ISO 10360 mpe values");
                    break;
            }

            return res;
        }

        /// <summary> Saves ASME B89 performance test of the specified CMM to the corresponding QIF structure. </summary>
        /// <param name="cmm"> CMM </param>
        /// <returns> QIF structure of ASME B89 performance test </returns>
        private qif30.CartesianCMMB89TestType SaveB89Results(CmmErrorB89 results)
        {
            return new qif30.CartesianCMMB89TestType()
            {
                XLinearAccuracy = Utilities.CreateLinearValue(results.XLinearAccuracy),
                YLinearAccuracy = Utilities.CreateLinearValue(results.YLinearAccuracy),
                ZLinearAccuracy = Utilities.CreateLinearValue(results.ZLinearAccuracy),
                OffsetVolumetricPerformance = Utilities.CreateLinearValue(results.OffsetVolumetricPerformance),
                Repeatability = Utilities.CreateLinearValue(results.Repeatability),
                VolumetricPerformance = Utilities.CreateLinearValue(results.VolumetricPerformance)
            };
        }

        /// <summary> Collects all sensors from all specified CMMs </summary>
        /// <param name="cmmParameters"> CMMs </param>
        /// <returns> Collected sensors </returns>
        private IReadOnlyList<SensorParameters> CollectSensors(IEnumerable<CmmParameters> cmmParameters)
        {
            return cmmParameters.SelectMany(cmm => cmm.SensorParameterList).Distinct().ToArray();
        }

        /// <summary> Saves the specified sensors to array of corresponding QIF structures </summary>
        /// <param name="sensorIds"> Map from sensors to their QIF identifiers </param>
        /// <param name="sensors"> Sensors to save </param>
        /// <param name="xmlObjectFactory"> Factory of QIF XML objects </param>
        /// <returns> Array of corresponding QIF structures </returns>
        private qif30.DetachableSensorBaseType[] SaveSensors(IDictionary<SensorParameters, uint> sensorIds, IReadOnlyList<SensorParameters> sensors, XmlObjectFactory xmlObjectFactory)
        {
            int n = sensors.Count;
            var res = new qif30.DetachableSensorBaseType[n];
            for (int i = 0; i < n; ++i)
            {
                res[i] = SaveSensor(sensors[i], xmlObjectFactory);
                sensorIds[sensors[i]] = res[i].id;
            }
            return res;
        }

        /// <summary> Saves the specified sensor to corresponding QIF structure </summary>
        /// <param name="sensor"> Sensor to save </param>
        /// <param name="xmlObjectFactory"> Factory of QIF XML objects </param>
        /// <returns> QIF sensor object </returns>
        private qif30.DetachableSensorBaseType SaveSensor(SensorParameters sensor, XmlObjectFactory xmlObjectFactory)
        {
            // create sensor by its type
            var xmlSensor = CreateXmlSensor(sensor, xmlObjectFactory);

            // Name
            xmlSensor.Name = sensor.Name;

            // Technology
            xmlSensor.Attributes.AddStringAttribute("Technology", Utilities.SensorTechnologyStrMap.ToString(sensor.Technology));

            // Active performance test
            xmlSensor.Attributes.AddStringAttribute("ActivePerformanceTest", Utilities.SensorPerfomanceTestStrMap.ToString(sensor.ActivePerformanceTest));

            // ISO performance test
            if (sensor.PerformanceTestIso10360 != null && sensor.PerformanceTestIso10360.Any())
                xmlSensor.Attributes.AddUserAttribute("PerformanceTestIso10360", xmlObjectFactory.CreateXmlElement("PerformanceTestIso10360", Utilities.D1ArrayToString(sensor.PerformanceTestIso10360)));

            // B89 performance test
            if (sensor.PerformanceTestB89 != null && sensor.PerformanceTestB89.Any())
                xmlSensor.Attributes.AddUserAttribute("PerformanceTestB89", xmlObjectFactory.CreateXmlElement("PerformanceTestB89", Utilities.D1ArrayToString(sensor.PerformanceTestB89)));

            // VDI/VDE performance test
            if (sensor.PerformanceTestVdiVde != null && sensor.PerformanceTestVdiVde.Any())
                xmlSensor.Attributes.AddUserAttribute("PerfomanceTestVdiVde", xmlObjectFactory.CreateXmlElement("PerfomanceTestVdiVde", Utilities.D1ArrayToString(sensor.PerformanceTestVdiVde)));

            // Standard deviation performance test
            if (sensor.PerformanceTestSpecifiedStandardDeviation != null && sensor.PerformanceTestSpecifiedStandardDeviation.Any())
                xmlSensor.Attributes.AddUserAttribute("PerfomanceStandardDeviation", xmlObjectFactory.CreateXmlElement("PerfomanceStandardDeviation", Utilities.D1ArrayToString(sensor.PerformanceTestSpecifiedStandardDeviation)));

            // Standard deviation performance test
            if (sensor.StylusLengths != null && sensor.StylusLengths.Any())
                xmlSensor.Attributes.AddUserAttribute("StylusLengths", xmlObjectFactory.CreateXmlElement("StylusLengths", Utilities.D1ArrayToString(sensor.StylusLengths)));

            // Extension length
            xmlSensor.Attributes.AddDecAttribute("ExtensionLength", sensor.ExtensionLength);

            // A Angle
            xmlSensor.Attributes.AddDecAttribute("AAngle", sensor.AAngle);

            // B Angle
            xmlSensor.Attributes.AddDecAttribute("BAngle", sensor.BAngle);

            // B Angle adjustment
            if (sensor.Type == SensorType.SingleTipArticulated)
                xmlSensor.Attributes.AddDecAttribute("BAngleAdjustment", sensor.BAngleAdjustment);

            return xmlSensor;
        }

        /// <summary> Creates a sensor object by its type </summary>
        /// <param name="sensor"> Sensor </param>
        /// <param name="factory"> Factory of QIF XML objects </param>
        /// <returns> QIF sensor object </returns>
        private qif30.DetachableSensorBaseType CreateXmlSensor(SensorParameters sensor, XmlObjectFactory factory)
        {
            if (sensor.Type == SensorType.SingleTipFixed)
                return factory.CreateSimpleTactileProbeSensor();

            var res = factory.CreateComplexTactileProbeSensor();
            res.Attributes.AddStringAttribute("Type", Utilities.SensorTypeUdaStrMap.ToString(sensor.Type));
            return res;
        }

        /// <summary> Loads sensors from the specified QIF measurement resources object </summary>
        /// <param name="mrs"> QIF Measurement resource object </param>
        /// <returns> Map from QIF identifiers to loaded sensors </returns>
        private IReadOnlyDictionary<uint, SensorParameters> LoadSensors(qif30.MeasurementResourcesType mrs)
        {
            var sensors = new Dictionary<uint, SensorParameters>();
            if (mrs.DetachableSensors == null || mrs.DetachableSensors.DetachableSensor == null)
                return sensors;

            foreach (var ds in mrs.DetachableSensors.DetachableSensor)
            {
                var sensor = LoadSensor(ds);
                if (sensor != null)
                {
                    if (sensors.ContainsKey(ds.id))
                        Errors.AddError(ds, "Two or sensors with the same id is found");
                    else
                        sensors.Add(ds.id, sensor);
                }
            }
            return sensors;
        }

        /// <summary> Loads sensor from QIF structure </summary>
        /// <param name="sensor"> QIF sensor object to load </param>
        /// <returns> Loaded sensor object </returns>
        private SensorParameters LoadSensor(qif30.DetachableSensorBaseType sensor)
        {
            var res = SensorParameters.CreateNewSensorParameters();
            var loader = new SensorLoader(sensor, Errors);

            // Name
            var name = loader.LoadName();
            if (!string.IsNullOrEmpty(name))
                res.Name = name;

            // Type
            var type = loader.LoadType();
            if (type.HasValue)
                res.Type = type.Value;

            // Technology
            var technology = loader.LoadTechnology();
            if (technology.HasValue)
                res.Technology = technology.Value;

            // Active performance test
            var activePerfomanceTest = loader.LoadActivePerformanceTest();
            if (activePerfomanceTest.HasValue)
                res.ActivePerformanceTest = activePerfomanceTest.Value;

            // ISO performance test
            var isoPerfomanceTest = loader.LoadPerfomanceTestIso();
            if (isoPerfomanceTest != null)
                res.PerformanceTestIso10360 = isoPerfomanceTest;

            // B89 performance test
            var b89PerformanceTest = loader.LoadPerfomanceTestB89();
            if (b89PerformanceTest != null)
                res.PerformanceTestB89 = b89PerformanceTest;

            // VDI/VDE performance test
            var vdiVdePermormanceTest = loader.LoadPerfomanceTestVdiVde();
            if (vdiVdePermormanceTest != null)
                res.PerformanceTestVdiVde = vdiVdePermormanceTest;

            // Specified Standard Deviation performance test
            var stdDevPerformanceTest = loader.LoadPerfomanceStandardDeviation();
            if (stdDevPerformanceTest != null)
                res.PerformanceTestSpecifiedStandardDeviation = stdDevPerformanceTest;

            // Stylus length(s)
            var stylusLengths = loader.LoadStylusLengths();
            if (stylusLengths != null)
                res.StylusLengths = stylusLengths;

            // Extension length
            var extensionLength = loader.LoadExtensionLength();
            if (extensionLength.HasValue)
                res.ExtensionLength = extensionLength.Value;

            // AAngle
            var aAngle = loader.LoadAAngle();
            if (aAngle.HasValue)
                res.AAngle = aAngle.Value;

            // BAngle
            var bAngle = loader.LoadBAngle();
            if (bAngle.HasValue)
                res.BAngle = bAngle.Value;

            // BAngle adjustment
            if (res.Type == SensorType.SingleTipArticulated)
            {
                var bAgleAdjustment = loader.LoadBAngleAdjustment();
                if (bAgleAdjustment.HasValue)
                    res.BAngleAdjustment = bAgleAdjustment.Value;
            }

            return res;
        }

        /// <summary> Loads CMM parameters from the specified QIF measurement resources object. </summary>
        /// <param name="mrs"> QIF measurement resources object </param>
        /// <param name="sensors"> Mapping of loaded sensors: QIF ID -> Sensor </param>
        /// <returns> Loaded CMM parameters </returns>
        private IReadOnlyList<CmmParameters> LoadCmms(qif30.MeasurementResourcesType mrs, IReadOnlyDictionary<uint, SensorParameters> sensors, FileUnits units)
        {
            var cmms = new List<CmmParameters>();
            foreach (var md in mrs.MeasurementDevices.MeasurementDevice)
            {
                var cmm = LoadCmm(md, sensors, units);
                if (cmm != null)
                    cmms.Add(cmm);
            }
            return cmms;
        }

        /// <summary> Loads CMM parameters from the specified QIF CMM object </summary>
        /// <param name="md"> QIF CMM object </param>
        /// <param name="sensors"> Mapping of loaded sensors: QIF ID -> Sensor </param>
        /// <returns> Loaded CMM parameters </returns>
        private CmmParameters LoadCmm(qif30.MeasurementDeviceType md, IReadOnlyDictionary<uint, SensorParameters> sensors, FileUnits units)
        {
            // Check type. Cartesian CMM only supported
            if (!(md is qif30.CartesianCMMType cartesian))
            {
                Errors.AddWarning("Skipped unsupported type of CMM", $"ID = {md.id}, type = {md.GetType()}");
                return null;
            }

            var cmm = CmmParameters.CreateNewCmmParameters();
            var loader = new CartesianCmmLoader(cartesian, units, Errors);

            // Name
            cmm.Name = cartesian.Name;

            // Extends <- Working volume
            var wv = loader.LoadCartesianWorkingVolume();
            if (wv.HasValue)
                cmm.Extents = wv.Value.ToArray();

            // Zero
            var zero = loader.LoadLowerExtent();
            if (zero.HasValue)
                cmm.Zero = zero.Value.ToArray();

            // Type
            var type = loader.LoadType();
            if (type.HasValue)
                cmm.Type = type.Value;

            // Axis orientation
            var axisOrientation = loader.LoadAxisOrientations();
            if (axisOrientation != null)
            {
                cmm.AxisOrientationX = axisOrientation.Value.x;
                cmm.AxisOrientationY = axisOrientation.Value.y;
                cmm.AxisOrientationZ = axisOrientation.Value.z;
            }

            // B89 performance test
            var b89Results = loader.LoadB89Results();
            if (b89Results != null)
                cmm.B89Results = b89Results;

            // ISO performance test
            var isoResults = loader.LoadIsoResults();
            if (isoResults != null)
                cmm.Iso10360Results = isoResults;

            // active performance test
            cmm.ActivePerformanceTest = loader.LoadActivePerformanceTest();

            // Sensors
            var sensorIds = loader.LoadSensorIds();
            foreach (var sid in sensorIds)
            {
                if (sensors.TryGetValue(sid, out var sensor))
                    cmm.AddSensor(sensor);
            }

            // Type of CMM scales
            var scales = loader.LoadCmmScales();
            if (scales != null)
            {
                cmm.CmmScales = scales.Item1;
                cmm.CmmExpansionCoefficient = scales.Item2;
                cmm.CmmExpansionCoefficientUncertainty = scales.Item3;
            }

            // Temperature
            var temperature = loader.LoadTemperature();
            if (temperature != null)
                cmm.CmmTemperature = temperature.Value;

            // Temperature uncertainty
            var temperatureUncertainty = loader.LoadTemperatureUncertainty();
            if (temperatureUncertainty > 0)
                cmm.CmmTemperatureUncertainty = temperatureUncertainty;

            // Laser air temperature/air temperature uncertainty
            var laserAirTemperature = loader.LoadCmmLaserAirTemperature();
            if (laserAirTemperature != null)
            {
                cmm.CmmLaserAirTemperature = laserAirTemperature.Item1;
                cmm.CmmLaserAirTemperatureUncertainty = laserAirTemperature.Item2;
            }

            // Laser air pressure/air pressure uncertainty
            var laserAirPressure = loader.LoadCmmLaserAirPressure();
            if (laserAirTemperature != null)
            {
                cmm.CmmLaserAirPressure = laserAirPressure.Item1;
                cmm.CmmLaserAirPressureUncertainty = laserAirPressure.Item2;
            }

            // Laser air humidity/air humidity uncertainty
            var laserAirHumidity = loader.LoadCmmLaserAirHumidity();
            if (laserAirHumidity != null)
            {
                cmm.CmmLaserAirHumidity = laserAirHumidity.Item1;
                cmm.CmmLaserAirHumidityUncertainty = laserAirHumidity.Item2;
            }

            // Software compensation
            var softwareCompensation = loader.LoadSoftwareCompensation();
            if (softwareCompensation.HasValue)
                cmm.CmmSoftwareCompensation = softwareCompensation.Value;

            // Rotary table
            cmm.HasRotaryTable = cartesian.RotaryTable != null;
            if (cartesian.RotaryTable != null)
            {
                var radius = units.LoadLengthValue(cartesian.RotaryTable.TableRadius);
                if (radius.HasValue)
                    cmm.RotaryTableRadius = radius.Value;

                // Origin
                var origin = loader.LoadRotaryTableLocation();
                if (origin.HasValue)
                {
                    cmm.RotaryTableXOrigin = origin.Value.x;
                    cmm.RotaryTableYOrigin = origin.Value.y;
                    cmm.RotaryTableZOrigin = origin.Value.z;
                }

                // Axis direction 
                var axisDirection = loader.LoadRotaryTableAxisDirection();
                if (axisDirection.HasValue)
                    cmm.RotaryTableAxisDirection = axisDirection.Value.ToArray();

                // Zero Index Direction
                var zeroIndexDirection = loader.LoadRotaryTableZeroIndexDirection();
                if (zeroIndexDirection.HasValue)
                    cmm.RotaryTableZeroIndexDirection = zeroIndexDirection.Value.ToArray();

                // Axial error
                var axialError = loader.LoadRotaryTableAxialError();
                if (axialError.HasValue)
                    cmm.RotaryTableAxialError = axialError.Value;

                // Radial error
                var radialError = loader.LoadRotaryTableRadialError();
                if (axialError.HasValue)
                    cmm.RotaryTableRadialError = radialError.Value;

                // Tangential error
                var tangentialError = loader.LoadRotaryTableTangentialError();
                if (axialError.HasValue)
                    cmm.RotaryTableTangentialError = tangentialError.Value;
            }

            return cmm;
        }

        /// <summary> Inherited from the parent </summary>
        public void Dispose() { }

        /// <summary> Path to the QIF file </summary>
        private string Path { get; }
    }
}
